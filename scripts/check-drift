#!/usr/bin/env python3
"""
Check system state against sources of truth (Containerfile, manifests).

Reports drift across three tiers:
  - Baked: RPM packages, system GNOME extensions (should match Containerfile)
  - Bootstrapped: Flatpaks, enabled extensions (should match manifests)
  - Optional: User-installed items beyond bootstrap

Exit codes:
  0 = no drift (or only optional-tier changes)
  1 = drift detected in baked or bootstrapped tiers
  2 = error collecting state
"""
from __future__ import annotations

import argparse
import json
import os
import re
import shlex
import subprocess
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import NamedTuple


# ─────────────────────────────────────────────────────────────────────────────
# Utilities
# ─────────────────────────────────────────────────────────────────────────────

def _run(cmd: list[str], *, check: bool = False) -> subprocess.CompletedProcess:
    cp = subprocess.run(cmd, text=True, capture_output=True, check=check)
    # Filter noisy rpm-ostree warnings about /dev/tty
    if cp.stderr and "Failed to open /dev/tty" in cp.stderr:
        filtered = "\n".join(
            line for line in cp.stderr.splitlines()
            if "Failed to open /dev/tty" not in line
        )
        cp = subprocess.CompletedProcess(cp.args, cp.returncode, cp.stdout, filtered)
    return cp


def _have(cmd: str) -> bool:
    return subprocess.run(
        ["bash", "-lc", f"command -v {shlex.quote(cmd)} >/dev/null 2>&1"]
    ).returncode == 0


def _running_in_toolbox() -> bool:
    if os.getenv("TOOLBOX_PATH") or os.getenv("container"):
        return True
    try:
        cgroup = Path("/proc/1/cgroup").read_text(errors="replace")
        if any(x in cgroup for x in ("toolbox", "podman", "docker", "libpod")):
            return True
    except Exception:
        pass
    return False


def _maybe_reexec_on_host(argv: list[str], *, repo_root: Path) -> None:
    if "--no-host" in argv:
        return
    if not _running_in_toolbox():
        return
    if not _have("flatpak-spawn"):
        return

    host_argv = [
        "flatpak-spawn", "--host",
        f"--directory={repo_root.resolve()}",
        "python3", str(Path(__file__).resolve()),
    ] + argv[1:] + ["--no-host"]

    cp = subprocess.run(host_argv, text=True, capture_output=True)
    if cp.stdout:
        sys.stdout.write(cp.stdout)
    if cp.stderr:
        # Filter noisy rpm-ostree warnings
        filtered = "\n".join(
            line for line in cp.stderr.splitlines()
            if "Failed to open /dev/tty" not in line
        )
        if filtered:
            sys.stderr.write(filtered + "\n")
    raise SystemExit(cp.returncode)


# ─────────────────────────────────────────────────────────────────────────────
# Source of Truth Parsers
# ─────────────────────────────────────────────────────────────────────────────

def parse_containerfile_packages(containerfile: Path) -> set[str]:
    """Extract packages from `dnf install -y ...` in the Containerfile."""
    if not containerfile.exists():
        return set()

    content = containerfile.read_text(errors="replace")
    packages: set[str] = set()

    # Match `dnf install -y pkg1 pkg2 ...` or `rpm-ostree install pkg1 pkg2 ...`
    # Handle multi-line continuations with backslash
    # Simplified: look for dnf install blocks
    pattern = r"(?:dnf|rpm-ostree)\s+install\s+-y\s+(.*?)(?:&&|;|\n(?!\s))"
    for match in re.finditer(pattern, content, re.DOTALL | re.IGNORECASE):
        block = match.group(1)
        # Remove backslash continuations and newlines
        block = re.sub(r"\\\n\s*", " ", block)
        # Extract package names (skip flags like -y)
        for token in block.split():
            token = token.strip()
            if token and not token.startswith("-") and not token.startswith("$"):
                packages.add(token)

    return packages


def parse_manifest_file(path: Path) -> set[str]:
    """Parse a tab-separated manifest file, extracting the relevant ID column."""
    if not path.exists():
        return set()

    items: set[str] = set()
    for line in path.read_text(errors="replace").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        parts = line.split("\t")
        # flatpak-apps.txt: scope, appid, remote -> take appid (column 1)
        # flatpak-remotes.txt: name, url, scope -> take name (column 0)
        # gnome-extensions.txt: just the uuid
        if len(parts) >= 2:
            items.add(parts[1].strip())  # appid for flatpak-apps
        else:
            items.add(parts[0].strip())  # uuid for extensions or remote name
    return items


def parse_flatpak_apps_manifest(path: Path) -> tuple[set[str], set[str]]:
    """Returns (system_apps, user_apps) from flatpak-apps.txt."""
    if not path.exists():
        return set(), set()

    system_apps: set[str] = set()
    user_apps: set[str] = set()

    for line in path.read_text(errors="replace").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        parts = line.split("\t")
        if len(parts) >= 2:
            scope = parts[0].strip()
            appid = parts[1].strip()
            if scope == "system":
                system_apps.add(appid)
            elif scope == "user":
                user_apps.add(appid)

    return system_apps, user_apps


def parse_flatpak_remotes_manifest(path: Path) -> set[str]:
    """Returns remote names from flatpak-remotes.txt."""
    if not path.exists():
        return set()

    remotes: set[str] = set()
    for line in path.read_text(errors="replace").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        parts = line.split("\t")
        if parts:
            remotes.add(parts[0].strip())

    return remotes


# ─────────────────────────────────────────────────────────────────────────────
# System State Collectors
# ─────────────────────────────────────────────────────────────────────────────

def get_rpm_packages() -> set[str]:
    """Get layered packages from rpm-ostree."""
    if not _have("rpm-ostree"):
        return set()

    cp = _run(["rpm-ostree", "status", "--json", "-q"])
    if cp.returncode != 0:
        return set()

    try:
        data = json.loads(cp.stdout)
        for d in data.get("deployments", []):
            if d.get("booted"):
                return set(d.get("packages", []))
    except Exception:
        pass

    return set()


def get_flatpak_apps() -> tuple[set[str], set[str]]:
    """Returns (system_apps, user_apps) currently installed."""
    if not _have("flatpak"):
        return set(), set()

    cp = _run(["flatpak", "list", "--app", "--columns=installation,application"])
    if cp.returncode != 0:
        return set(), set()

    system_apps: set[str] = set()
    user_apps: set[str] = set()

    for line in cp.stdout.splitlines():
        parts = line.strip().split("\t")
        if len(parts) >= 2:
            installation = parts[0].strip()
            appid = parts[1].strip()
            if installation == "system":
                system_apps.add(appid)
            elif installation == "user":
                user_apps.add(appid)

    return system_apps, user_apps


def get_flatpak_remotes() -> set[str]:
    """Get installed flatpak remote names."""
    if not _have("flatpak"):
        return set()

    cp = _run(["flatpak", "remotes", "--columns=name"])
    if cp.returncode != 0:
        return set()

    return {line.strip() for line in cp.stdout.splitlines() if line.strip()}


def get_gnome_extensions() -> tuple[set[str], set[str]]:
    """Returns (system_extensions, user_extensions) from filesystem."""
    user_dir = Path.home() / ".local" / "share" / "gnome-shell" / "extensions"
    system_dir = Path("/usr/share/gnome-shell/extensions")

    def _list(d: Path) -> set[str]:
        if not d.exists():
            return set()
        return {e.name for e in d.iterdir() if e.is_dir()}

    return _list(system_dir), _list(user_dir)


# ─────────────────────────────────────────────────────────────────────────────
# Drift Detection
# ─────────────────────────────────────────────────────────────────────────────

class DriftItem(NamedTuple):
    category: str      # e.g., "rpm-packages", "flatpak-apps", "gnome-extensions"
    tier: str          # "baked", "bootstrapped", "optional"
    drift_type: str    # "missing", "extra", "unexpected"
    item: str          # the package/app/extension name


@dataclass
class DriftReport:
    items: list[DriftItem] = field(default_factory=list)
    errors: list[str] = field(default_factory=list)

    def add(self, category: str, tier: str, drift_type: str, item: str):
        self.items.append(DriftItem(category, tier, drift_type, item))

    def has_critical_drift(self) -> bool:
        """Returns True if there's drift in baked or bootstrapped tiers."""
        return any(i.tier in ("baked", "bootstrapped") for i in self.items)

    def to_dict(self) -> dict:
        by_tier: dict[str, dict[str, list[str]]] = {
            "baked": {},
            "bootstrapped": {},
            "optional": {},
        }
        for item in self.items:
            key = f"{item.category}:{item.drift_type}"
            if key not in by_tier[item.tier]:
                by_tier[item.tier][key] = []
            by_tier[item.tier][key].append(item.item)

        return {
            "drift": by_tier,
            "errors": self.errors,
            "has_critical_drift": self.has_critical_drift(),
        }


def detect_drift(repo_root: Path, manifests_dir: Path) -> DriftReport:
    report = DriftReport()

    containerfile = repo_root / "Containerfile"

    # ─── Baked Tier: RPM packages ───
    # Note: This is tricky because the current system is still on stock Bazzite.
    # Once switched to bootc image, layered packages should be empty (all baked).
    # For now, we compare against what the Containerfile *will* install.
    expected_packages = parse_containerfile_packages(containerfile)
    # We can't easily compare RPM packages since they're baked into the image.
    # This check is more useful post-switch. Skip for now with a note.

    # ─── Bootstrapped Tier: Flatpak apps ───
    manifest_system_apps, manifest_user_apps = parse_flatpak_apps_manifest(
        manifests_dir / "flatpak-apps.txt"
    )
    manifest_apps = manifest_system_apps | manifest_user_apps

    installed_system_apps, installed_user_apps = get_flatpak_apps()
    installed_apps = installed_system_apps | installed_user_apps

    # Missing from bootstrap manifest = installed but not in manifest (could be optional)
    for app in sorted(installed_apps - manifest_apps):
        report.add("flatpak-apps", "optional", "extra", app)

    # In manifest but not installed = drift
    for app in sorted(manifest_apps - installed_apps):
        report.add("flatpak-apps", "bootstrapped", "missing", app)

    # ─── Bootstrapped Tier: Flatpak remotes ───
    manifest_remotes = parse_flatpak_remotes_manifest(manifests_dir / "flatpak-remotes.txt")
    installed_remotes = get_flatpak_remotes()

    for remote in sorted(manifest_remotes - installed_remotes):
        report.add("flatpak-remotes", "bootstrapped", "missing", remote)

    # Extra remotes are fine (optional tier)
    for remote in sorted(installed_remotes - manifest_remotes):
        report.add("flatpak-remotes", "optional", "extra", remote)

    # ─── Bootstrapped Tier: GNOME extensions ───
    manifest_extensions = parse_manifest_file(manifests_dir / "gnome-extensions.txt")
    system_extensions, user_extensions = get_gnome_extensions()
    installed_extensions = system_extensions | user_extensions

    for ext in sorted(manifest_extensions - installed_extensions):
        report.add("gnome-extensions", "bootstrapped", "missing", ext)

    for ext in sorted(installed_extensions - manifest_extensions):
        report.add("gnome-extensions", "optional", "extra", ext)

    return report


# ─────────────────────────────────────────────────────────────────────────────
# Output Formatters
# ─────────────────────────────────────────────────────────────────────────────

COLORS = {
    "red": "\033[91m",
    "green": "\033[92m",
    "yellow": "\033[93m",
    "blue": "\033[94m",
    "reset": "\033[0m",
    "bold": "\033[1m",
}


def _c(color: str, text: str, *, use_color: bool = True) -> str:
    if not use_color:
        return text
    return f"{COLORS.get(color, '')}{text}{COLORS['reset']}"


def format_human(report: DriftReport, *, color: bool = True) -> str:
    lines: list[str] = []

    if not report.items and not report.errors:
        lines.append(_c("green", "✓ No drift detected", use_color=color))
        return "\n".join(lines)

    tier_labels = {
        "baked": ("BAKED", "red"),
        "bootstrapped": ("BOOTSTRAPPED", "yellow"),
        "optional": ("OPTIONAL", "blue"),
    }

    # Group by tier
    by_tier: dict[str, list[DriftItem]] = {"baked": [], "bootstrapped": [], "optional": []}
    for item in report.items:
        by_tier[item.tier].append(item)

    for tier in ["baked", "bootstrapped", "optional"]:
        items = by_tier[tier]
        if not items:
            continue

        label, label_color = tier_labels[tier]
        lines.append("")
        lines.append(_c(label_color, f"═══ {label} TIER ═══", use_color=color))

        # Group by category
        by_category: dict[str, list[DriftItem]] = {}
        for item in items:
            if item.category not in by_category:
                by_category[item.category] = []
            by_category[item.category].append(item)

        for category, cat_items in sorted(by_category.items()):
            lines.append(f"  {category}:")
            for item in sorted(cat_items, key=lambda x: (x.drift_type, x.item)):
                symbol = "+" if item.drift_type == "extra" else "-"
                desc = "missing" if item.drift_type == "missing" else "not in manifest"
                lines.append(f"    {symbol} {item.item} ({desc})")

    if report.errors:
        lines.append("")
        lines.append(_c("red", "═══ ERRORS ═══", use_color=color))
        for err in report.errors:
            lines.append(f"  {err}")

    lines.append("")
    if report.has_critical_drift():
        lines.append(_c("red", "✗ Drift detected in baked/bootstrapped tiers", use_color=color))
    else:
        lines.append(_c("green", "✓ Only optional-tier differences (OK)", use_color=color))

    return "\n".join(lines)


# ─────────────────────────────────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────────────────────────────────

def main() -> None:
    parser = argparse.ArgumentParser(
        description="Check system state against sources of truth (Containerfile, manifests)"
    )
    parser.add_argument(
        "--json", action="store_true",
        help="Output as JSON instead of human-readable"
    )
    parser.add_argument(
        "--no-color", action="store_true",
        help="Disable colored output"
    )
    parser.add_argument(
        "--no-host", action="store_true",
        help="Don't re-exec on host via flatpak-spawn"
    )
    parser.add_argument(
        "--repo-root", default=None,
        help="Repository root path (for development; defaults to /usr/local/share/bootc-bootstrap)"
    )
    args = parser.parse_args()

    # In the baked image, manifests live at /usr/local/share/bootc-bootstrap
    # During development, use --repo-root to point to the repo
    if args.repo_root:
        repo_root = Path(args.repo_root)
        manifests_dir = repo_root / "manifests"
    else:
        # Check if we're in the baked image or in a dev environment
        baked_manifests = Path("/usr/local/share/bootc-bootstrap")
        if baked_manifests.exists():
            manifests_dir = baked_manifests
            repo_root = Path("/")  # Not used for Containerfile in production
        else:
            # Fallback to current directory for development
            repo_root = Path.cwd()
            manifests_dir = repo_root / "manifests"

    _maybe_reexec_on_host(sys.argv, repo_root=repo_root)

    report = detect_drift(repo_root, manifests_dir)

    if args.json:
        print(json.dumps(report.to_dict(), indent=2, sort_keys=True))
    else:
        use_color = not args.no_color and sys.stdout.isatty()
        print(format_human(report, color=use_color))

    if report.errors:
        sys.exit(2)
    elif report.has_critical_drift():
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == "__main__":
    main()
