#!/usr/bin/env bash
set -euo pipefail

cmd="${1:-apply}"

share_dir="/usr/share/bootc-bootstrap"
state_dir="${XDG_STATE_HOME:-$HOME/.local/state}/bootc-bootstrap"
state_file="${state_dir}/last-applied.sha256"

log() {
  printf "[bootc-bootstrap] %s\n" "$*" >&2
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1
}

manifest_hash() {
  if ! compgen -G "${share_dir}/*" >/dev/null; then
    printf "";
    return 0
  fi
  (cd "${share_dir}" && sha256sum ./* 2>/dev/null || true) | sha256sum | cut -d" " -f1
}

run_flatpak() {
  local scope="$1"; shift
  if [[ "$scope" == system* ]]; then
    if need_cmd pkexec; then
      pkexec flatpak "$@"
    else
      log "pkexec missing; skipping system flatpak: flatpak $*"
      return 1
    fi
  else
    flatpak --user "$@"
  fi
}

apply_flatpak_remotes() {
  local file="${share_dir}/flatpak-remotes.json"
  [[ -f "$file" ]] || return 0
  need_cmd flatpak || { log "flatpak not found; skipping flatpak remotes"; return 1; }
  need_cmd jq || { log "jq not found; skipping flatpak remotes"; return 1; }

  local count
  count="$(jq -r '.remotes | length' "$file")"

  for ((i=0; i<count; i++)); do
    local name url scope
    name="$(jq -r ".remotes[$i].name" "$file")"
    url="$(jq -r ".remotes[$i].url" "$file")"
    scope="$(jq -r ".remotes[$i].scope" "$file")"

    log "Ensuring flatpak remote (${scope}): ${name} ${url}"
    run_flatpak "${scope}" remote-add --if-not-exists "${name}" "${url}" || return 1
  done
}

apply_flatpak_apps() {
  local file="${share_dir}/flatpak-apps.json"
  [[ -f "$file" ]] || return 0
  need_cmd flatpak || { log "flatpak not found; skipping flatpak apps"; return 1; }
  need_cmd jq || { log "jq not found; skipping flatpak apps"; return 1; }

  local count
  count="$(jq -r '.apps | length' "$file")"

  for ((i=0; i<count; i++)); do
    local appid remote scope
    appid="$(jq -r ".apps[$i].id" "$file")"
    remote="$(jq -r ".apps[$i].remote" "$file")"
    scope="$(jq -r ".apps[$i].scope" "$file")"

    log "Installing/updating flatpak (${scope}): ${appid} (${remote})"
    run_flatpak "${scope}" install -y --noninteractive --or-update "${remote}" "${appid}" || return 1
  done
}

shell_major_version() {
  local v
  v="$(gnome-shell --version 2>/dev/null || true)"
  # "GNOME Shell 47.2" -> 47
  printf "%s" "$v" | grep -Eo '[0-9]+' | head -n1
}

apply_gnome_extensions() {
  local file="${share_dir}/gnome-extensions.json"
  [[ -f "$file" ]] || return 0

  need_cmd gnome-extensions || { log "gnome-extensions not found; skipping extensions"; return 1; }
  need_cmd curl || { log "curl not found; skipping extensions"; return 1; }
  need_cmd jq || { log "jq not found; skipping extensions"; return 1; }

  local shell_ver
  shell_ver="$(shell_major_version)"
  if [[ -z "$shell_ver" ]]; then
    log "Could not detect GNOME Shell version; skipping extensions"
    return 1
  fi

  local tmpdir
  tmpdir="$(mktemp -d)"
  trap 'rm -rf "$tmpdir"' EXIT

  local count
  count="$(jq -r '.extensions | length' "$file")"

  for ((i=0; i<count; i++)); do
    local uuid enabled
    local item
    item="$(jq -r ".extensions[$i]" "$file")"

    # Handle both string format and object format
    if [[ "$item" == "{"* ]]; then
      # Object format: {"id": "...", "enabled": true/false}
      uuid="$(jq -r ".extensions[$i].id" "$file")"
      enabled="$(jq -r ".extensions[$i].enabled // true" "$file")"
    else
      # String format: just the UUID (implies enabled=true)
      uuid="$item"
      enabled="true"
    fi

    # Skip disabled extensions
    if [[ "$enabled" != "true" ]]; then
      log "Skipping disabled extension: ${uuid}"
      continue
    fi

    if gnome-extensions info "${uuid}" >/dev/null 2>&1; then
      log "Enabling GNOME extension: ${uuid}"
      gnome-extensions enable "${uuid}" >/dev/null 2>&1 || true
      continue
    fi

    log "Installing GNOME extension: ${uuid} (shell ${shell_ver})"

    info_json="$(curl -fsSL "https://extensions.gnome.org/extension-info/?uuid=${uuid}&shell_version=${shell_ver}")" || { log "Failed to fetch extension info for ${uuid}"; return 1; }
    dl_path="$(printf "%s" "$info_json" | jq -r '.download_url // empty')"
    if [[ -z "$dl_path" ]]; then
      log "No download_url for ${uuid}; skipping"
      continue
    fi

    zip_path="${tmpdir}/${uuid}.zip"
    curl -fsSL "https://extensions.gnome.org${dl_path}" -o "${zip_path}" || { log "Failed to download ${uuid}"; return 1; }

    gnome-extensions install --force "${zip_path}" || { log "Failed to install ${uuid}"; return 1; }
    gnome-extensions enable "${uuid}" >/dev/null 2>&1 || true
  done
}

apply_gsettings() {
  local file="${share_dir}/gsettings.json"
  [[ -f "$file" ]] || return 0

  need_cmd gsettings || { log "gsettings not found; skipping gsettings"; return 0; }
  need_cmd jq || { log "jq not found; skipping gsettings"; return 0; }

  local count
  count="$(jq -r '.settings | length' "$file")"

  for ((i=0; i<count; i++)); do
    local schema key value
    schema="$(jq -r ".settings[$i].schema" "$file")"
    key="$(jq -r ".settings[$i].key" "$file")"
    value="$(jq -r ".settings[$i].value" "$file")"

    log "Applying gsettings: ${schema} ${key} ${value}"
    gsettings set "${schema}" "${key}" ${value} || true
  done
}

apply_host_shims() {
  # Generate host shims from manifest
  # The 'bkt shim' command handles merging system + user manifests
  if need_cmd bkt; then
    log "Syncing host shims"
    bkt shim sync || log "bkt shim sync failed (non-fatal)"
  else
    log "bkt command not found; skipping host shims"
  fi
}

apply_distrobox() {
  local ini="/etc/distrobox/distrobox.ini"
  [[ -f "$ini" ]] || { log "No distrobox.ini found at ${ini}; skipping"; return 0; }
  need_cmd distrobox || { log "distrobox not found; skipping distrobox setup"; return 1; }

  # Parse container names from ini and check if they already exist
  local needs_create=false
  while IFS= read -r name; do
    if ! podman container exists "$name" 2>/dev/null; then
      log "Distrobox container '${name}' missing; will create"
      needs_create=true
    fi
  done < <(grep -oP '^\[\K[^\]]+' "$ini")

  if [[ "$needs_create" == "false" ]]; then
    log "All distrobox containers already exist; skipping"
    return 0
  fi

  log "Assembling distrobox containers from ${ini}"
  distrobox assemble create --file "$ini" || return 1
}

apply_composefs_font_workaround() {
  # Chromium/Electron apps fail to render non-Latin glyphs (complex scripts,
  # emoji) from composefs overlay fonts when fontconfig's user cache contains
  # stale entries from a previous OS deployment or fontconfig version.
  #
  # Root cause: fontconfig caches font metadata (charset, OTL capabilities,
  # named instances) in ~/.cache/fontconfig/. On image-based systems like
  # bootc/ostree, OS upgrades replace the composefs root (new inodes, new font
  # builds). Old cache files (especially cross-version formats like
  # cache-reindex1-10 alongside cache-9/cache-11) are not invalidated by
  # `fc-cache -f` and cause fontconfig to return stale metadata to Chromium.
  # Latin glyphs render because they use basic cmap lookups; complex scripts
  # fail because their OTL layout/capability data is stale.
  #
  # Fix: clear the entire fontconfig cache directory, then rebuild. This is
  # gated on the ostree deployment checksum so it only runs once per upgrade.

  # Skip if root is not a composefs overlay
  local root_fstype
  root_fstype="$(stat -f -c '%T' / 2>/dev/null || true)"
  if [[ "$root_fstype" != "overlay" && "$root_fstype" != "overlayfs" ]]; then
    return 0
  fi

  local marker_file="${state_dir}/fontcache-deployment"

  # Use the ostree deployment checksum as the gate
  local current_deployment=""
  if need_cmd rpm-ostree && need_cmd jq; then
    current_deployment="$(rpm-ostree status --json 2>/dev/null \
      | jq -r '.deployments[0].checksum // empty' 2>/dev/null || true)"
  fi

  if [[ -n "$current_deployment" && -f "$marker_file" ]]; then
    if [[ "$(cat "$marker_file" 2>/dev/null || true)" == "$current_deployment" ]]; then
      log "Fontconfig cache valid for deployment ${current_deployment:0:12}..."
      return 0
    fi
  fi

  log "Clearing stale fontconfig cache (deployment changed)"
  rm -rf "${HOME}/.cache/fontconfig"
  mkdir -p "${HOME}/.cache/fontconfig"
  fc-cache -f 2>/dev/null || true

  # Remove legacy font mirror if present (no longer needed)
  local legacy_mirror="${HOME}/.local/share/fonts/composefs-mirror"
  if [[ -d "$legacy_mirror" ]]; then
    log "Removing legacy font mirror ($(du -sh "$legacy_mirror" 2>/dev/null | cut -f1))"
    rm -rf "$legacy_mirror"
    fc-cache 2>/dev/null || true
  fi

  if [[ -n "$current_deployment" ]]; then
    mkdir -p "${state_dir}"
    printf "%s\n" "$current_deployment" > "$marker_file"
  fi

  log "Fontconfig cache rebuilt for current deployment"
}

apply_all() {
  # Distrobox runs outside the hash gate: missing containers are a runtime
  # issue (e.g. podman reset) not a manifest-change issue. The check is
  # cheap (podman container exists) and the function is idempotent.
  apply_distrobox || log "distrobox setup failed (non-fatal; will retry next login)"

  # Fontconfig cache clear also runs outside the hash gate: it's keyed on
  # the ostree deployment checksum, not the manifest hash.
  apply_composefs_font_workaround || log "font workaround failed (non-fatal)"

  local hash
  hash="$(manifest_hash)"

  mkdir -p "${state_dir}"
  if [[ -n "$hash" && -f "${state_file}" ]]; then
    if [[ "$(tr -d '\n' < "${state_file}" || true)" == "$hash" ]]; then
      log "Already applied (manifest hash ${hash}); exiting"
      return 0
    fi
  fi

  local failed=0

  apply_flatpak_remotes || failed=1
  apply_flatpak_apps || failed=1
  apply_gnome_extensions || failed=1
  apply_gsettings || failed=1
  apply_host_shims  # Non-fatal; don't set failed

  if [[ $failed -ne 0 ]]; then
    log "One or more steps failed; will retry next login"
    return 0
  fi

  # Clone the repo so bkt commands can find manifests (RFC-0053).
  # This is the transition from "system manifests" to "repo is truth."
  clone_repo || log "repo clone failed (non-fatal; bkt will clone on first PR)"

  if [[ -n "$hash" ]]; then
    printf "%s\n" "$hash" > "${state_file}"
    log "Applied successfully (manifest hash ${hash})"
  fi
}

clone_repo() {
  local repo_json="/usr/share/bootc/repo.json"
  local cache_dir="${XDG_STATE_HOME:-$HOME/.local/state}/bkt"
  local cache_file="${cache_dir}/repo-path"

  # Skip if repo path is already cached and valid
  if [[ -f "$cache_file" ]]; then
    local cached
    cached="$(<"$cache_file")"
    if [[ -d "${cached}/manifests" ]]; then
      log "Repo already cloned at ${cached}"
      return 0
    fi
  fi

  # Read clone coordinates from image-baked repo.json
  if [[ ! -f "$repo_json" ]]; then
    log "No repo.json at ${repo_json}; skipping clone"
    return 1
  fi

  need_cmd jq || { log "jq not found; skipping repo clone"; return 1; }

  local owner name
  owner="$(jq -r .owner "$repo_json")"
  name="$(jq -r .name "$repo_json")"

  if [[ -z "$owner" || -z "$name" ]]; then
    log "Invalid repo.json; skipping clone"
    return 1
  fi

  local clone_target="${HOME}/Code/Config/${name}"

  if [[ -d "${clone_target}/manifests" ]]; then
    log "Repo exists at ${clone_target}"
  elif need_cmd gh; then
    log "Cloning ${owner}/${name} to ${clone_target}..."
    mkdir -p "$(dirname "$clone_target")"
    gh repo clone "${owner}/${name}" "$clone_target" -- --depth=1
  else
    log "gh CLI not available; skipping clone"
    return 1
  fi

  # Cache the path for find_repo_path()
  if [[ -d "${clone_target}/manifests" ]]; then
    mkdir -p "$cache_dir"
    printf "%s" "$clone_target" > "$cache_file"
    log "Repo path cached at ${cache_file}"
  else
    log "Clone target missing manifests/; not caching"
    return 1
  fi
}

case "$cmd" in
  apply)
    apply_all
    ;;
  *)
    echo "Usage: bootc-bootstrap [apply]" >&2
    exit 2
    ;;
esac
