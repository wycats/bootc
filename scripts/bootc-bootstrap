#!/usr/bin/env bash
set -euo pipefail

cmd="${1:-apply}"

share_dir="/usr/share/bootc-bootstrap"
state_dir="${XDG_STATE_HOME:-$HOME/.local/state}/bootc-bootstrap"
state_file="${state_dir}/last-applied.sha256"

log() {
  printf "[bootc-bootstrap] %s\n" "$*" >&2
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1
}

manifest_hash() {
  if ! compgen -G "${share_dir}/*" >/dev/null; then
    printf "";
    return 0
  fi
  (cd "${share_dir}" && sha256sum ./* 2>/dev/null || true) | sha256sum | cut -d" " -f1
}

run_flatpak() {
  local scope="$1"; shift
  if [[ "$scope" == system* ]]; then
    if need_cmd pkexec; then
      pkexec flatpak "$@"
    else
      log "pkexec missing; skipping system flatpak: flatpak $*"
      return 1
    fi
  else
    flatpak --user "$@"
  fi
}

apply_flatpak_remotes() {
  local file="${share_dir}/flatpak-remotes.json"
  [[ -f "$file" ]] || return 0
  need_cmd flatpak || { log "flatpak not found; skipping flatpak remotes"; return 1; }
  need_cmd jq || { log "jq not found; skipping flatpak remotes"; return 1; }

  local count
  count="$(jq -r '.remotes | length' "$file")"

  for ((i=0; i<count; i++)); do
    local name url scope
    name="$(jq -r ".remotes[$i].name" "$file")"
    url="$(jq -r ".remotes[$i].url" "$file")"
    scope="$(jq -r ".remotes[$i].scope" "$file")"

    log "Ensuring flatpak remote (${scope}): ${name} ${url}"
    run_flatpak "${scope}" remote-add --if-not-exists "${name}" "${url}" || return 1
  done
}

apply_flatpak_apps() {
  local file="${share_dir}/flatpak-apps.json"
  [[ -f "$file" ]] || return 0
  need_cmd flatpak || { log "flatpak not found; skipping flatpak apps"; return 1; }
  need_cmd jq || { log "jq not found; skipping flatpak apps"; return 1; }

  local count
  count="$(jq -r '.apps | length' "$file")"

  for ((i=0; i<count; i++)); do
    local appid remote scope
    appid="$(jq -r ".apps[$i].id" "$file")"
    remote="$(jq -r ".apps[$i].remote" "$file")"
    scope="$(jq -r ".apps[$i].scope" "$file")"

    log "Installing/updating flatpak (${scope}): ${appid} (${remote})"
    run_flatpak "${scope}" install -y --noninteractive --or-update "${remote}" "${appid}" || return 1
  done
}

shell_major_version() {
  local v
  v="$(gnome-shell --version 2>/dev/null || true)"
  # "GNOME Shell 47.2" -> 47
  printf "%s" "$v" | grep -Eo '[0-9]+' | head -n1
}

apply_gnome_extensions() {
  local file="${share_dir}/gnome-extensions.json"
  [[ -f "$file" ]] || return 0

  need_cmd gnome-extensions || { log "gnome-extensions not found; skipping extensions"; return 1; }
  need_cmd curl || { log "curl not found; skipping extensions"; return 1; }
  need_cmd jq || { log "jq not found; skipping extensions"; return 1; }

  local shell_ver
  shell_ver="$(shell_major_version)"
  if [[ -z "$shell_ver" ]]; then
    log "Could not detect GNOME Shell version; skipping extensions"
    return 1
  fi

  local tmpdir
  tmpdir="$(mktemp -d)"
  trap 'rm -rf "$tmpdir"' EXIT

  local count
  count="$(jq -r '.extensions | length' "$file")"

  for ((i=0; i<count; i++)); do
    local uuid enabled
    local item
    item="$(jq -r ".extensions[$i]" "$file")"

    # Handle both string format and object format
    if [[ "$item" == "{"* ]]; then
      # Object format: {"id": "...", "enabled": true/false}
      uuid="$(jq -r ".extensions[$i].id" "$file")"
      enabled="$(jq -r ".extensions[$i].enabled // true" "$file")"
    else
      # String format: just the UUID (implies enabled=true)
      uuid="$item"
      enabled="true"
    fi

    # Skip disabled extensions
    if [[ "$enabled" != "true" ]]; then
      log "Skipping disabled extension: ${uuid}"
      continue
    fi

    if gnome-extensions info "${uuid}" >/dev/null 2>&1; then
      log "Enabling GNOME extension: ${uuid}"
      gnome-extensions enable "${uuid}" >/dev/null 2>&1 || true
      continue
    fi

    log "Installing GNOME extension: ${uuid} (shell ${shell_ver})"

    info_json="$(curl -fsSL "https://extensions.gnome.org/extension-info/?uuid=${uuid}&shell_version=${shell_ver}")" || { log "Failed to fetch extension info for ${uuid}"; return 1; }
    dl_path="$(printf "%s" "$info_json" | jq -r '.download_url // empty')"
    if [[ -z "$dl_path" ]]; then
      log "No download_url for ${uuid}; skipping"
      continue
    fi

    zip_path="${tmpdir}/${uuid}.zip"
    curl -fsSL "https://extensions.gnome.org${dl_path}" -o "${zip_path}" || { log "Failed to download ${uuid}"; return 1; }

    gnome-extensions install --force "${zip_path}" || { log "Failed to install ${uuid}"; return 1; }
    gnome-extensions enable "${uuid}" >/dev/null 2>&1 || true
  done
}

apply_gsettings() {
  local file="${share_dir}/gsettings.json"
  [[ -f "$file" ]] || return 0

  need_cmd gsettings || { log "gsettings not found; skipping gsettings"; return 0; }
  need_cmd jq || { log "jq not found; skipping gsettings"; return 0; }

  local count
  count="$(jq -r '.settings | length' "$file")"

  for ((i=0; i<count; i++)); do
    local schema key value
    schema="$(jq -r ".settings[$i].schema" "$file")"
    key="$(jq -r ".settings[$i].key" "$file")"
    value="$(jq -r ".settings[$i].value" "$file")"

    log "Applying gsettings: ${schema} ${key} ${value}"
    gsettings set "${schema}" "${key}" ${value} || true
  done
}

apply_host_shims() {
  # Generate host shims from manifest
  # The 'bkt shim' command handles merging system + user manifests
  if need_cmd bkt; then
    log "Syncing host shims"
    bkt shim sync || log "bkt shim sync failed (non-fatal)"
  else
    log "bkt command not found; skipping host shims"
  fi
}

apply_distrobox() {
  local ini="/etc/distrobox/distrobox.ini"
  [[ -f "$ini" ]] || { log "No distrobox.ini found at ${ini}; skipping"; return 0; }
  need_cmd distrobox || { log "distrobox not found; skipping distrobox setup"; return 1; }

  # Parse container names from ini and check if they already exist
  local needs_create=false
  while IFS= read -r name; do
    if ! podman container exists "$name" 2>/dev/null; then
      log "Distrobox container '${name}' missing; will create"
      needs_create=true
    fi
  done < <(grep -oP '^\[\K[^\]]+' "$ini")

  if [[ "$needs_create" == "false" ]]; then
    log "All distrobox containers already exist; skipping"
    return 0
  fi

  log "Assembling distrobox containers from ${ini}"
  distrobox assemble create --file "$ini" || return 1
}

apply_all() {
  # Distrobox runs outside the hash gate: missing containers are a runtime
  # issue (e.g. podman reset) not a manifest-change issue. The check is
  # cheap (podman container exists) and the function is idempotent.
  apply_distrobox || log "distrobox setup failed (non-fatal; will retry next login)"

  local hash
  hash="$(manifest_hash)"

  mkdir -p "${state_dir}"
  if [[ -n "$hash" && -f "${state_file}" ]]; then
    if [[ "$(tr -d '\n' < "${state_file}" || true)" == "$hash" ]]; then
      log "Already applied (manifest hash ${hash}); exiting"
      return 0
    fi
  fi

  local failed=0

  apply_flatpak_remotes || failed=1
  apply_flatpak_apps || failed=1
  apply_gnome_extensions || failed=1
  apply_gsettings || failed=1
  apply_host_shims  # Non-fatal; don't set failed

  if [[ $failed -ne 0 ]]; then
    log "One or more steps failed; will retry next login"
    return 0
  fi

  if [[ -n "$hash" ]]; then
    printf "%s\n" "$hash" > "${state_file}"
    log "Applied successfully (manifest hash ${hash})"
  fi
}

case "$cmd" in
  apply)
    apply_all
    ;;
  *)
    echo "Usage: bootc-bootstrap [apply]" >&2
    exit 2
    ;;
esac
