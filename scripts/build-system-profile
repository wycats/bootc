#!/usr/bin/env python3
import argparse
import ast
import datetime as _dt
import json
import os
import platform
import re
import shlex
import socket
import subprocess
import sys
from pathlib import Path


def _run(cmd: list[str], *, check: bool = False) -> subprocess.CompletedProcess:
    cp = subprocess.run(cmd, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=check)
    # When running via `flatpak-spawn --host`, some host tools (notably rpm-ostree)
    # may not have a controlling TTY and emit a noisy warning. It's not actionable
    # for our purposes; keep stderr clean unless there are real errors.
    if cp.stderr and "Failed to open /dev/tty" in cp.stderr:
        filtered = []
        for line in cp.stderr.splitlines():
            if "Failed to open /dev/tty" in line:
                continue
            filtered.append(line)
        cp = subprocess.CompletedProcess(
            args=cp.args,
            returncode=cp.returncode,
            stdout=cp.stdout,
            stderr=("\n".join(filtered)).strip() + ("\n" if filtered else ""),
        )
    return cp


def _have(cmd: str) -> bool:
    return subprocess.run(["bash", "-lc", f"command -v {shlex.quote(cmd)} >/dev/null 2>&1"]).returncode == 0


def _running_in_toolbox_like_container() -> bool:
    # Heuristics only: we just want to know whether "host inspection" is likely
    # to be wrong unless we re-exec via flatpak-spawn --host.
    if os.getenv("TOOLBOX_PATH") or os.getenv("container"):
        return True
    try:
        cgroup = Path("/proc/1/cgroup").read_text(encoding="utf-8", errors="replace")
        if any(x in cgroup for x in ("toolbox", "podman", "docker", "containerd", "libpod")):
            return True
    except Exception:
        pass
    return False


def _maybe_reexec_on_host(argv: list[str], *, repo_root: Path) -> None:
    # If we're in a toolbox/container, we likely can't see host rpm-ostree
    # deployments, /etc drift, or host-installed flatpaks. Prefer host execution.
    #
    # This is intentionally conservative: on a real host, this should be a no-op.
    if "--no-host" in argv:
        return

    if not _running_in_toolbox_like_container():
        return

    if not _have("flatpak-spawn"):
        return

    # Re-exec this script on the host, preserving args, but preventing recursion.
    script_path = Path(__file__).resolve()
    host_argv = [
        "flatpak-spawn",
        "--host",
        f"--directory={str(repo_root.resolve())}",
        "python3",
        str(script_path),
    ] + argv[1:] + ["--no-host"]

    # Hand over control to the host execution.
    # We capture output so we can filter a known noisy warning from host tools
    # launched without a controlling TTY (common under flatpak-spawn --host).
    cp = subprocess.run(host_argv, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if cp.stdout:
        sys.stdout.write(cp.stdout)

    if cp.stderr:
        filtered_lines: list[str] = []
        for line in cp.stderr.splitlines(True):
            if "rpm-ostree: Failed to open /dev/tty" in line:
                continue
            filtered_lines.append(line)
        if filtered_lines:
            sys.stderr.write("".join(filtered_lines))

    raise SystemExit(cp.returncode)


def _read_os_release() -> dict:
    path = Path("/etc/os-release")
    if not path.exists():
        return {}
    data: dict[str, str] = {}
    for line in path.read_text(encoding="utf-8", errors="replace").splitlines():
        line = line.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        k, v = line.split("=", 1)
        data[k] = v.strip().strip('"')
    return data


def _rpm_ostree_status() -> dict:
    if not _have("rpm-ostree"):
        return {"available": False}

    # Prefer JSON output when available.
    cp = _run(["rpm-ostree", "status", "--json", "-q"])
    if cp.returncode != 0:
        return {
            "available": True,
            "error": "rpm-ostree status --json failed",
            "stderr": cp.stderr.strip(),
        }

    try:
        raw = json.loads(cp.stdout)
    except Exception as e:
        return {
            "available": True,
            "error": f"failed to parse rpm-ostree JSON: {e}",
        }

    deployments = raw.get("deployments") or []
    booted = None
    for d in deployments:
        if d.get("booted") is True:
            booted = d
            break
    if booted is None and deployments:
        booted = deployments[0]

    if booted is None:
        return {"available": True, "error": "no deployments found"}

    # Fields vary across rpm-ostree versions; keep it flexible.
    requested = booted.get("requested-packages") or booted.get("requested_packages") or []
    requested_local = booted.get("requested-local-packages") or booted.get("requested_local_packages") or []
    layered = booted.get("packages") or []

    return {
        "available": True,
        "booted": {
            "checksum": booted.get("checksum"),
            "origin": booted.get("origin"),
            "base-checksum": booted.get("base-checksum") or booted.get("base_checksum"),
            "version": booted.get("version"),
            "timestamp": booted.get("timestamp"),
            "requested-packages": sorted(set(requested)),
            "requested-local-packages": sorted(set(requested_local)),
            "layered-packages": sorted(set(layered)),
        },
    }


def _ostree_config_diff() -> dict:
    # On ostree systems, this is the canonical "what in /etc is different" command.
    if not _have("ostree"):
        return {"available": False}

    def _parse(out: str) -> list[dict]:
        changes = []
        for line in out.splitlines():
            line = line.rstrip("\n")
            if not line.strip():
                continue
            # Typical format: "M    etc/ssh/sshd_config" or "A    etc/foo".
            m = re.match(r"^([AMD])\s+(.+)$", line.strip())
            if not m:
                continue
            changes.append({"op": m.group(1), "path": m.group(2)})
        return changes

    cp = _run(["ostree", "admin", "config-diff"])
    if cp.returncode != 0:
        stderr = cp.stderr.strip()
        # Best-effort: config-diff may require root on some setups.
        if "must be root" in stderr.lower() and _have("sudo"):
            sudo_cp = _run(["sudo", "-n", "ostree", "admin", "config-diff"])
            if sudo_cp.returncode == 0:
                return {"available": True, "changes": _parse(sudo_cp.stdout), "used_sudo": True}
            return {
                "available": True,
                "error": "ostree admin config-diff failed",
                "stderr": stderr,
                "sudo_error": sudo_cp.stderr.strip(),
            }

        return {
            "available": True,
            "error": "ostree admin config-diff failed",
            "stderr": stderr,
        }

    return {"available": True, "changes": _parse(cp.stdout)}


def _flatpak_state() -> dict:
    if not _have("flatpak"):
        return {"available": False}

    out: dict = {"available": True}

    # Remotes: use supported columns; "system" is encoded in the "options" column.
    rem = _run(["flatpak", "remotes", "--columns=name,url,options,filter"])
    if rem.returncode == 0:
        remotes = []
        for line in rem.stdout.splitlines():
            line = line.strip()
            if not line:
                continue
            parts = [p.strip() for p in line.split("\t")]
            # name, url, options, filter
            if len(parts) >= 2:
                options = parts[2] if len(parts) > 2 else ""
                filt = parts[3] if len(parts) > 3 else ""
                remotes.append(
                    {
                        "name": parts[0],
                        "url": parts[1],
                        "options": options,
                        "filter": "" if filt == "-" else filt,
                        "system": "system" in (options.split(",") if options else []),
                        "filtered": "filtered" in (options.split(",") if options else []),
                    }
                )
        out["remotes"] = remotes
    else:
        out["remotes_error"] = {
            "stderr": rem.stderr.strip(),
        }

    # Include both system and user app installs.
    # Note: the supported column set varies across Flatpak versions; avoid "commit" for compatibility.
    lst = _run(
        [
            "flatpak",
            "list",
            "--app",
            "--columns=installation,application,origin,branch,version",
        ]
    )
    if lst.returncode == 0:
        apps = []
        for line in lst.stdout.splitlines():
            line = line.strip()
            if not line:
                continue
            parts = [p.strip() for p in line.split("\t")]
            if len(parts) >= 2:
                apps.append(
                    {
                        "installation": parts[0],
                        "application": parts[1],
                        "origin": parts[2] if len(parts) > 2 else "",
                        "branch": parts[3] if len(parts) > 3 else "",
                        "version": parts[4] if len(parts) > 4 else "",
                    }
                )
        out["apps"] = apps
    else:
        out["apps_error"] = {
            "stderr": lst.stderr.strip(),
        }

    return out


def _gnome_extensions() -> dict:
    if not _have("gnome-extensions"):
        return {"available": False}

    cp = _run(["gnome-extensions", "list"])
    if cp.returncode != 0:
        return {"available": True, "error": "gnome-extensions list failed", "stderr": cp.stderr.strip()}

    extensions = []
    for uuid in cp.stdout.splitlines():
        uuid = uuid.strip()
        if not uuid:
            continue
        info = _run(["gnome-extensions", "info", uuid])
        enabled = None
        if info.returncode == 0:
            # Parse "State: ENABLED" etc.
            m = re.search(r"^State:\s*(\S+)\s*$", info.stdout, flags=re.MULTILINE)
            if m:
                enabled = (m.group(1).upper() == "ENABLED")
        extensions.append({"uuid": uuid, "enabled": enabled})

    return {"available": True, "extensions": extensions}


def _gnome_extensions_filesystem() -> dict:
    # Works without a GNOME session; just inventories installed extension directories.
    user_dir = Path.home() / ".local" / "share" / "gnome-shell" / "extensions"
    system_dir = Path("/usr/share/gnome-shell/extensions")

    def _list_ext(dirpath: Path) -> list[str]:
        if not dirpath.exists() or not dirpath.is_dir():
            return []
        out: list[str] = []
        for entry in dirpath.iterdir():
            if entry.is_dir():
                out.append(entry.name)
        return sorted(set(out))

    return {
        "available": True,
        "user_dir": str(user_dir),
        "system_dir": str(system_dir),
        "installed": {
            "user": _list_ext(user_dir),
            "system": _list_ext(system_dir),
        },
    }


def _gnome_enabled_extensions() -> dict:
    # Best-effort: try gsettings (may require a user session bus).
    if not _have("gsettings"):
        return {"available": False}

    cp = _run(["gsettings", "get", "org.gnome.shell", "enabled-extensions"])
    if cp.returncode != 0:
        return {
            "available": True,
            "error": "gsettings get org.gnome.shell enabled-extensions failed",
            "stderr": cp.stderr.strip(),
        }

    raw = cp.stdout.strip()
    enabled: list[str] | None = None
    try:
        parsed = ast.literal_eval(raw)
        if isinstance(parsed, (list, tuple)):
            enabled = [str(x) for x in parsed]
    except Exception:
        enabled = None

    if enabled is None:
        return {"available": True, "raw": raw}

    return {"available": True, "enabled": sorted(set(enabled))}


def _load_bootstrap_manifests(repo_root: Path) -> dict:
    apps_path = repo_root / "manifests" / "flatpak-apps.json"
    remotes_path = repo_root / "manifests" / "flatpak-remotes.json"
    gnome_ext_path = repo_root / "manifests" / "gnome-extensions.json"

    want_apps: set[str] = set()
    if apps_path.exists():
        try:
            data = json.loads(apps_path.read_text(encoding="utf-8", errors="replace"))
            for app in data.get("apps", []):
                if app.get("id"):
                    want_apps.add(app["id"])
        except Exception:
            pass

    want_remotes: set[str] = set()
    if remotes_path.exists():
        try:
            data = json.loads(remotes_path.read_text(encoding="utf-8", errors="replace"))
            for remote in data.get("remotes", []):
                if remote.get("name"):
                    want_remotes.add(remote["name"])
        except Exception:
            pass

    want_gnome_exts: set[str] = set()
    if gnome_ext_path.exists():
        try:
            data = json.loads(gnome_ext_path.read_text(encoding="utf-8", errors="replace"))
            want_gnome_exts = set(data.get("extensions", []))
        except Exception:
            pass

    return {
        "flatpak-appids": sorted(want_apps),
        "flatpak-remotes": sorted(want_remotes),
        "gnome-extension-uuids": sorted(want_gnome_exts),
    }


def main() -> None:
    ap = argparse.ArgumentParser(description="Generate a machine-readable system profile (JSON)")
    ap.add_argument("--output", help="Write JSON to this path (default: stdout)")
    ap.add_argument("--text-output", help="Write a human-readable snapshot to this path")
    ap.add_argument(
        "--no-host",
        action="store_true",
        help="Do not auto re-exec via flatpak-spawn --host (primarily for debugging)",
    )
    ap.add_argument(
        "--repo-root",
        default=str(Path.cwd()),
        help="Repo root path (used to compare installed Flatpaks vs manifests)",
    )
    args = ap.parse_args()

    repo_root = Path(args.repo_root)

    _maybe_reexec_on_host(sys.argv, repo_root=repo_root)

    profile: dict = {
        "generated_at": _dt.datetime.now(tz=_dt.timezone.utc).isoformat(),
        "host": {
            "hostname": socket.gethostname(),
            "fqdn": socket.getfqdn(),
            "kernel": platform.release(),
            "arch": platform.machine(),
            "user": os.getenv("USER") or "",
        },
        "os_release": _read_os_release(),
        "rpm_ostree": _rpm_ostree_status(),
        "etc_config_diff": _ostree_config_diff(),
        "flatpak": _flatpak_state(),
        "gnome_extensions": _gnome_extensions(),
        "gnome_extensions_filesystem": _gnome_extensions_filesystem(),
        "gnome_enabled_extensions": _gnome_enabled_extensions(),
        "bootstrap_manifests": _load_bootstrap_manifests(repo_root),
    }

    # If flatpak state is available, provide a quick comparison section.
    if profile["flatpak"].get("available") and "apps" in profile["flatpak"]:
        installed = {a.get("application") for a in profile["flatpak"]["apps"] if a.get("application")}
        desired = set(profile["bootstrap_manifests"].get("flatpak-appids") or [])
        profile["flatpak_manifest_diff"] = {
            "installed_not_in_manifest": sorted(installed - desired),
            "manifest_not_installed": sorted(desired - installed),
        }

    if profile["flatpak"].get("available") and "remotes" in profile["flatpak"]:
        installed_remotes = {r.get("name") for r in profile["flatpak"]["remotes"] if r.get("name")}
        desired_remotes = set(profile["bootstrap_manifests"].get("flatpak-remotes") or [])
        profile["flatpak_remote_manifest_diff"] = {
            "installed_not_in_manifest": sorted(installed_remotes - desired_remotes),
            "manifest_not_installed": sorted(desired_remotes - installed_remotes),
        }

    # GNOME extension comparisons.
    gmf = profile.get("gnome_extensions_filesystem") or {}
    if gmf.get("available"):
        installed_exts = set((gmf.get("installed") or {}).get("user") or []) | set(
            (gmf.get("installed") or {}).get("system") or []
        )
        desired_exts = set(profile["bootstrap_manifests"].get("gnome-extension-uuids") or [])
        profile["gnome_extensions_manifest_diff"] = {
            "installed_not_in_manifest": sorted(installed_exts - desired_exts),
            "manifest_not_installed": sorted(desired_exts - installed_exts),
        }

        gee = profile.get("gnome_enabled_extensions") or {}
        if gee.get("available") and "enabled" in gee:
            enabled_exts = set(gee.get("enabled") or [])
            profile["gnome_extensions_enabled_vs_installed"] = {
                "enabled_not_installed": sorted(enabled_exts - installed_exts),
                "installed_but_not_enabled": sorted(installed_exts - enabled_exts),
            }

    out = json.dumps(profile, indent=2, sort_keys=True)
    if args.output:
        Path(args.output).write_text(out + "\n", encoding="utf-8")
    else:
        print(out)

    if args.text_output:
        lines: list[str] = []
        lines.append(f"generated_at: {profile['generated_at']}")
        lines.append(f"hostname: {profile['host'].get('hostname','')}")
        osr = profile.get("os_release") or {}
        if osr:
            lines.append(f"os: {osr.get('PRETTY_NAME', '')}")

        lines.append("")
        lines.append("=== LAYERED PACKAGES (rpm-ostree) ===")
        ro = profile.get("rpm_ostree") or {}
        if ro.get("available") and ro.get("booted"):
            pkgs = ro["booted"].get("requested-packages") or []
            for p in pkgs:
                lines.append(p)
        else:
            lines.append("(unavailable)")

        lines.append("")
        lines.append("=== /etc CHANGES (ostree admin config-diff) ===")
        cd = profile.get("etc_config_diff") or {}
        if cd.get("available"):
            changes = cd.get("changes") or []
            if not changes:
                lines.append("(no changes)")
            else:
                for c in changes:
                    lines.append(f"{c.get('op','?')}\t{c.get('path','')}")
        else:
            lines.append("(unavailable)")

        lines.append("")
        lines.append("=== FLATPAK APPS (installed) ===")
        fp = profile.get("flatpak") or {}
        if fp.get("available"):
            apps = fp.get("apps") or []
            if not apps:
                lines.append("(none)")
            else:
                for a in apps:
                    lines.append(
                        "\t".join(
                            [
                                a.get("installation", ""),
                                a.get("application", ""),
                                a.get("origin", ""),
                                a.get("branch", ""),
                                a.get("version", ""),
                            ]
                        ).rstrip("\t")
                    )
        else:
            lines.append("(unavailable)")

        lines.append("")
        lines.append("=== FLATPAK vs BOOTSTRAP MANIFEST ===")
        fpd = profile.get("flatpak_manifest_diff") or {}
        if fpd:
            lines.append("installed_not_in_manifest:")
            for appid in fpd.get("installed_not_in_manifest") or []:
                lines.append(f"- {appid}")
            lines.append("manifest_not_installed:")
            for appid in fpd.get("manifest_not_installed") or []:
                lines.append(f"- {appid}")
        else:
            lines.append("(unavailable)")

        lines.append("")
        lines.append("=== GNOME EXTENSIONS (installed; filesystem) ===")
        gmf = profile.get("gnome_extensions_filesystem") or {}
        if gmf.get("available"):
            inst = gmf.get("installed") or {}
            user_exts = inst.get("user") or []
            sys_exts = inst.get("system") or []
            lines.append("user:")
            for uuid in user_exts:
                lines.append(f"- {uuid}")
            lines.append("system:")
            for uuid in sys_exts:
                lines.append(f"- {uuid}")
        else:
            lines.append("(unavailable)")

        lines.append("")
        lines.append("=== GNOME EXTENSIONS (enabled; gsettings best-effort) ===")
        gee = profile.get("gnome_enabled_extensions") or {}
        if gee.get("available") and "enabled" in gee:
            for uuid in gee.get("enabled") or []:
                lines.append(f"- {uuid}")
        elif gee.get("available") and "raw" in gee:
            lines.append(gee.get("raw") or "")
        else:
            lines.append("(unavailable)")

        lines.append("")
        lines.append("=== GNOME EXTENSIONS vs BOOTSTRAP MANIFEST ===")
        gxd = profile.get("gnome_extensions_manifest_diff") or {}
        if gxd:
            lines.append("installed_not_in_manifest:")
            for uuid in gxd.get("installed_not_in_manifest") or []:
                lines.append(f"- {uuid}")
            lines.append("manifest_not_installed:")
            for uuid in gxd.get("manifest_not_installed") or []:
                lines.append(f"- {uuid}")
        else:
            lines.append("(unavailable)")

        Path(args.text_output).write_text("\n".join(lines) + "\n", encoding="utf-8")


if __name__ == "__main__":
    main()
