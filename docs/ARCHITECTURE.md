# Architecture: bkt Internals

## Command Structure

```
bkt
├── apply           # Sync all manifests to system (bootstrap/recovery)
├── capture         # Capture system state to manifests (daily use)
├── status          # Show drift between manifests and system (planned)
├── containerfile   # Regenerate Containerfile from manifests
├── distrobox       # Distrobox-specific operations
│   ├── apply       # Sync distrobox containers
│   └── capture     # Capture distrobox state (planned)
└── [subsystem]     # Per-subsystem commands (flatpak, appimage, etc.)
```

## The Plannable Trait

The core abstraction is the `Plannable` trait, which separates "what to do" from "doing it":

```rust
pub trait Plannable {
    type Plan;

    fn plan(&self) -> Result<Self::Plan>;
    fn is_empty(&self) -> bool;  // For drift detection
}
```

Each subsystem implements this trait:

- `FlatpakApps` → `FlatpakPlan`
- `AppImageApps` → `AppImagePlan`
- `DistroboxContainers` → `DistroboxPlan`
- etc.

The plan can be inspected, displayed, and then executed. This enables:

1. **Dry-run** — Show what would change without doing it
2. **Confirmation** — Present changes to user before applying
3. **Drift detection** — Compare manifests to system state

## Runtime Context Detection

`bkt` detects where it's running and delegates appropriately:

```rust
pub fn detect_context() -> RuntimeContext {
    if std::path::Path::new("/run/.toolboxenv").exists() {
        RuntimeContext::Toolbox
    } else if std::path::Path::new("/run/.containerenv").exists() {
        RuntimeContext::Container
    } else if std::env::var("CONTAINER_ID").is_ok() {
        RuntimeContext::Container
    } else {
        RuntimeContext::Host
    }
}
```

### Delegation Rules

| Command               | From Host        | From Toolbox                        |
| --------------------- | ---------------- | ----------------------------------- |
| `bkt apply`           | Execute directly | Delegate via `flatpak-spawn --host` |
| `bkt distrobox apply` | Execute directly | Delegate via `flatpak-spawn --host` |
| `bkt capture`         | Execute directly | Delegate via `flatpak-spawn --host` |

## Managed Sections in Containerfiles

The main `Containerfile` uses managed sections that are regenerated from manifests:

```dockerfile
# === SYSTEM_PACKAGES (managed by bkt) ===
RUN rpm-ostree install \
    package1 \
    package2 \
    ...
# === END SYSTEM_PACKAGES ===
```

Section types:

| Section            | Source Manifest        | Purpose                    |
| ------------------ | ---------------------- | -------------------------- |
| `SYSTEM_PACKAGES`  | `system-packages.json` | DNF/rpm-ostree packages    |
| `COPR_REPOS`       | `system-packages.json` | COPR repository enablement |
| `HOST_SHIMS`       | `host-shims.json`      | Flatpak-spawn wrappers     |
| `KERNEL_ARGUMENTS` | (inline)               | Kernel boot parameters     |
| `SYSTEMD_UNITS`    | (inline)               | Systemd unit enablement    |

### Planned: Toolbox Managed Sections

The `toolbox/Containerfile` should eventually support:

| Section                | Purpose                                  |
| ---------------------- | ---------------------------------------- |
| `TOOLBOX_PACKAGES`     | Build dependencies and development tools |
| `TOOLCHAIN_INSTALLERS` | rustup, proto installation               |

## Distrobox Integration

### Manifest → INI → Assemble

```
manifests/distrobox.json
        ↓ (bkt generates)
distrobox.ini
        ↓ (distrobox reads)
distrobox assemble create
```

### Container Configuration

```json
{
  "bootc-dev": {
    "image": "ghcr.io/wycats/bootc-toolbox:latest",
    "packages": [], // System packages (prefer image-baked)
    "init_hooks": ["rustup update stable", "proto install node"],
    "bins": {
      "from": ["~/.cargo/bin", "~/.proto/bin", "~/.proto/shims"],
      "also": ["nu"]
    }
  }
}
```

### Export Mechanism

Distrobox exports work by creating wrapper scripts in `/usr/bin` that execute the container binary:

```bash
# /usr/bin/cargo (generated by distrobox-export)
#!/bin/sh
exec distrobox-enter bootc-dev -- cargo "$@"
```

## File Locations

### Manifests

```
manifests/
├── system-packages.json     # Tier 1: bootc image packages
├── flatpak-apps.json        # Tier 2: Flatpak applications
├── flatpak-remotes.json     # Tier 2: Flatpak repositories
├── appimage-apps.json       # Tier 2: AppImage applications
├── gnome-extensions.json    # Tier 2: GNOME Shell extensions
├── gsettings.json           # Tier 2: GNOME settings
├── distrobox.json           # Tier 2: Distrobox containers
└── host-shims.json          # Tier 1: Host command wrappers
```

### Generated Files

```
Containerfile              # Main bootc image (managed sections)
distrobox.ini              # Distrobox assembly config
toolbox/Containerfile      # Toolbox image (TODO: managed sections)
```

### System Locations

```
~/.local/share/appimages/  # AppImage storage
~/.local/bin/              # User binaries (including bkt)
/usr/bin/                  # Distrobox exports land here
```

## Error Handling Philosophy

1. **Fail fast with context** — Include stderr/stdout in error messages
2. **Progress visibility** — Show what's happening during long operations
3. **Confirmation before destructive actions** — `bkt apply` requires `--confirm` or interactive approval
4. **Safe defaults** — Keep unmanaged items unless explicitly told to prune
