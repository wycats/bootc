# RFC 0047: bkt wrap — Generated Application Wrappers

**Status**: Draft  
**Created**: 2026-02-15  
**Depends on**: RFC 0046 (Memory Resource Controls)

## Summary

Replace shell wrapper scripts with `bkt`-generated Rust binaries for launching applications under systemd resource controls. This eliminates shell quoting issues, improves error handling, and provides a single source of truth for wrapper logic.

## Motivation

RFC 0046 introduced memory resource controls via shell wrapper scripts (`scripts/code-managed`, `scripts/msedge-managed`). These scripts have several fragility points:

1. **`which -a` behavior varies** — Can return multiple lines, may not exist on all systems
2. **Shell quoting complexity** — Arguments with spaces, special characters
3. **Silent failures** — Missing binaries, failed `systemd-run` calls
4. **IPC passthrough complexity** — VS Code remote-cli detection is error-prone
5. **No build-time validation** — Errors only surface at runtime

A Rust binary eliminates all of these issues and integrates naturally with the `bkt` toolchain.

## Design

### New Command: `bkt wrap`

```bash
# Generate wrapper for VS Code
bkt wrap generate \
  --name code \
  --target /usr/share/code/bin/code \
  --slice app-vscode.slice \
  --output /usr/bin/code

# Generate wrapper for Edge
bkt wrap generate \
  --name msedge \
  --target /usr/bin/microsoft-edge-stable \
  --slice app-msedge.slice \
  --output /usr/bin/microsoft-edge-stable
```

### Generated Binary Behavior

The generated wrapper:

1. **Detects VS Code remote-cli mode** — If `VSCODE_IPC_HOOK_CLI` is set, searches `PATH` for the remote-cli binary and delegates to it
2. **Validates target exists** — Fails with clear error if the wrapped binary is missing
3. **Invokes systemd-run** — Launches the target in the configured slice with proper scope naming
4. **Preserves exit codes** — Propagates the target's exit status
5. **Handles signals** — Forwards SIGTERM/SIGINT to the child process

### Wrapper Source Template

```rust
//! Auto-generated by bkt wrap
//! Target: {target}
//! Slice: {slice}

use std::env;
use std::os::unix::process::CommandExt;
use std::process::{Command, exit};

fn main() {
    // VS Code remote-cli passthrough
    if env::var("VSCODE_IPC_HOOK_CLI").is_ok() {
        if let Some(remote_cli) = find_remote_cli() {
            let err = Command::new(&remote_cli)
                .args(env::args().skip(1))
                .exec();
            eprintln!("Failed to exec remote-cli: {}", err);
            exit(1);
        }
    }

    // Validate target exists
    let target = "{target}";
    if !std::path::Path::new(target).exists() {
        eprintln!("Error: {} not found", target);
        exit(127);
    }

    // Launch via systemd-run
    let unit_name = format!("{name}-{}-{}",
        std::process::id(),
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .subsec_nanos()
    );

    let err = Command::new("systemd-run")
        .args([
            "--user",
            "--slice={slice}",
            "--scope",
            &format!("--unit={}", unit_name),
            "--description={name} (managed)",
            "--property=MemoryOOMGroup=yes",
            "--",
            target,
        ])
        .args(env::args().skip(1))
        .exec();

    eprintln!("Failed to exec systemd-run: {}", err);
    exit(1);
}

fn find_remote_cli() -> Option<String> {
    let path = env::var("PATH").ok()?;
    for dir in path.split(':') {
        let candidate = format!("{}/code", dir);
        if candidate.contains("/remote-cli/") && std::path::Path::new(&candidate).exists() {
            return Some(candidate);
        }
    }
    None
}
```

### Manifest Integration

Add a new module type `wrapper` to `image-config.json`:

```json
{
  "name": "vscode-wrapper",
  "type": "wrapper",
  "comment": "VS Code memory-managed wrapper",
  "target": "/usr/share/code/bin/code",
  "slice": "app-vscode.slice",
  "output": "/usr/bin/code",
  "remote_cli": true
}
```

The generator:

1. Compiles the wrapper binary during `bkt containerfile generate`
2. Includes it in the collect-config stage
3. Sets appropriate permissions

### Build Integration

Wrappers are compiled as part of the image build:

```dockerfile
# In collect-config stage
COPY --from=bkt-build /wrappers/code /usr/bin/code
COPY --from=bkt-build /wrappers/microsoft-edge-stable /usr/bin/microsoft-edge-stable
```

Or, for simplicity in the initial implementation, `bkt wrap generate` can be run locally and the binaries committed to the repo (like we do with `bkt` itself).

## Implementation Plan

### Phase 1: Core Command

1. Add `bkt wrap generate` command
2. Implement wrapper template with systemd-run invocation
3. Add VS Code remote-cli detection

### Phase 2: Manifest Integration

1. Add `wrapper` module type to image-config schema
2. Update containerfile generator to handle wrapper modules
3. Generate wrappers during build

### Phase 3: Cleanup

1. Remove shell wrapper scripts
2. Update RFC 0046 to reference this RFC
3. Update Containerfile

## Alternatives Considered

### Keep Shell Scripts

Simpler but fragile. The `which -a` and quoting issues are real problems.

### systemd Socket Activation

Could use socket-activated services, but adds complexity and doesn't solve the CLI invocation case.

### Desktop File Modification Only

Only covers GUI launches, not terminal/script invocations.

## Security Considerations

- Wrappers run as the invoking user (no privilege escalation)
- `systemd-run --user` creates user-scoped cgroups
- Binary is compiled from known source, not downloaded

## Testing

1. Unit tests for remote-cli detection logic
2. Integration test: launch VS Code, verify it's in correct slice
3. Integration test: `code --help` works (argument passthrough)
4. Integration test: VS Code remote-cli mode works from terminal

## References

- RFC 0046: Memory Resource Controls
- systemd-run(1) man page
- VS Code remote CLI documentation
