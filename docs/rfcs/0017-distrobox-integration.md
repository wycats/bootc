# RFC 0017: Distrobox Integration and Exported Shims

- Feature Name: `distrobox_integration`
- Start Date: 2026-01-20
- RFC PR: (leave this empty until PR is opened)
- Tracking Issue: (leave this empty)

## Summary

Integrate Distrobox as the primary developer container workflow, using `distrobox.ini` as the native target configuration and a new bkt manifest as the git-tracked source of truth. `bkt` will capture and apply Distrobox configuration, including exported binaries (shims), additional packages, and hooks, while letting Distrobox handle the actual container lifecycle via `distrobox assemble`. Binary locations are **declarative**: manifests list explicit paths, not runtime discovery.

The goal is to shift the default workflow to **host-first** development (VS Code on host), with exported shims running inside the Distrobox container. This reduces the need for delegation logic and eliminates most "run inside the container" friction.

## Motivation

The current toolbox-based workflow assumes users operate **inside** the container, then delegate to the host for actions like `flatpak`, `gnome-extensions`, and `gsettings`. This has caused ongoing friction:

- Frequent context switching between host and container
- Heavy reliance on `flatpak-spawn --host`
- VS Code often needs to attach to the container
- Complex detection and delegation paths

Distrobox provides a better fit for the intended user experience by supporting **exported binaries**, allowing the user to stay on the host while seamlessly executing tools inside the container. Distrobox also provides a declarative manifest (`distrobox.ini`) that can be treated as a native system artifact similar to gsettings and flatpak overrides.

### Guiding Principles

1. **Host-first workflow**: Developers live on the host; tool execution is delegated into the container via exported shims.
2. **Native format as target**: `distrobox.ini` is the system state; bkt captures/applies it.
3. **GitOps source of truth**: A bkt manifest controls the desired state, generating `distrobox.ini` and applying it.
4. **Avoid toolchain lock-in**: Use Distrobox’s native features wherever possible (assemble, export).

## Goals

- Support Distrobox as the preferred dev-container backend
- Manage exported binaries (shims) declaratively
- Capture and apply `distrobox.ini` through bkt
- Preserve a git-tracked manifest as the source of truth
- Minimize need for container delegation logic

## Non-Goals

- Supporting multiple users or multi-machine orchestration
- Replacing Distrobox’s own configuration tools
- Rewriting Distrobox features inside bkt

## Guide-level Explanation

### New Workflow (Host-First)

```
Host (VS Code, shell)
  └── exported shim (cargo, rustc, npm, etc.)
        └── distrobox enter bootc-dev -- <command>
```

### Distrobox as Native Target

bkt treats `distrobox.ini` as the native state in the same way it treats gsettings and flatpak state:

```
┌─────────────────────┐
│  distrobox.ini      │  ← Native Distrobox config
└──────────┬──────────┘
           │ capture / apply
┌──────────▼──────────┐
│  manifests/         │  ← Git-tracked source of truth
│  distrobox.json     │
└─────────────────────┘
```

### Example bkt Manifest

```json
{
  "$schema": "../schemas/distrobox.schema.json",
  "containers": {
    "bootc-dev": {
      "image": "ghcr.io/wycats/bootc-toolbox:latest",
      "exported_bins": [
        "~/.cargo/bin/cargo",
        "~/.cargo/bin/rustc",
        "~/.cargo/bin/cargo-clippy",
        "~/.cargo/bin/cargo-fmt",
        "~/.proto/shims/node",
        "/usr/bin/npm",
        "/usr/local/bin/nu"
      ],
      "exported_bins_path": "~/.local/bin",
      "path": ["~/.local/bin", "~/.cargo/bin", "~/.proto/bin", "$PATH"],
      "env": { "RUST_BACKTRACE": "1" },
      "additional_flags": ["--userns=keep-id"],
      "init_hooks": ["rustup default stable"],
      "pull": true,
      "init": false,
      "root": false
    }
  }
}
```

### Generated `distrobox.ini`

```ini
# Generated by bkt
# Source: manifests/distrobox.json

[bootc-dev]
image=ghcr.io/wycats/bootc-toolbox:latest
exported_bins="~/.cargo/bin/cargo ~/.cargo/bin/rustc ~/.cargo/bin/cargo-clippy ~/.cargo/bin/cargo-fmt ~/.proto/shims/node /usr/bin/npm /usr/local/bin/nu"
exported_bins_path="~/.local/bin"
init_hooks="rustup default stable"
pull=true
init=false
root=false
additional_flags="--env=PATH=~/.local/bin:~/.cargo/bin:~/.proto/bin:$PATH --env=RUST_BACKTRACE=1 --userns=keep-id"
```

### Commands

```bash
# Capture current distrobox.ini into manifest
bkt distrobox capture

# Apply manifest to regenerate distrobox.ini and run assemble
bkt distrobox apply

# Update manifest directly (optional convenience)
bkt distrobox export add /usr/bin/cargo
bkt distrobox package add git vim
```

## Reference-level Explanation

### New Manifest Type

Add a new manifest file:

- `manifests/distrobox.json`
- Schema: `schemas/distrobox.schema.json`

### Distrobox INI Mapping

| Manifest Field       | Distrobox INI Key        | Notes                           |
| -------------------- | ------------------------ | ------------------------------- |
| `image`              | `image`                  | Required                        |
| `packages`           | `additional_packages`    | Joined as space-separated list  |
| `exported_bins`      | `exported_bins`          | Space-separated explicit paths  |
| `exported_bins_path` | `exported_bins_path`     | Default `~/.local/bin`          |
| `exported_apps`      | `exported_apps`          | Optional                        |
| `init_hooks`         | `init_hooks`             | One per line or compound list   |
| `pre_init_hooks`     | `pre_init_hooks`         | Optional                        |
| `volume`             | `volume`                 | Optional                        |
| `pull`               | `pull`                   | Boolean                         |
| `init`               | `init`                   | Boolean                         |
| `root`               | `root`                   | Boolean                         |
| `path`               | (via `additional_flags`) | See PATH Configuration below    |
| `env`                | (via `additional_flags`) | See Environment Variables below |
| `additional_flags`   | `additional_flags`       | Pass-through; cannot set PATH   |

### PATH Configuration

The `path` field provides shell-agnostic PATH configuration for the container environment.

**Schema:**

```json
{
  "path": ["~/.local/bin", "~/.cargo/bin"]
}
```

**Semantics:**

- Array of directory paths
- Prepended to `$PATH` by default
- Include literal `"$PATH"` to control placement
- Empty array = no PATH modification

**Examples:**

```json
// Default: prepend to PATH
"path": ["~/.local/bin"]
// → --env=PATH=~/.local/bin:$PATH

// Explicit placement
"path": ["~/.local/bin", "$PATH", "/opt/fallback"]
// → --env=PATH=~/.local/bin:$PATH:/opt/fallback
```

**Why shell-agnostic?** Using `--env=PATH=...` via `additional_flags` is set by the container runtime before any shell starts. Works for bash, zsh, nushell, fish, or any process.

### Deterministic Binary Locations

`bkt` does **not** infer binary locations (no `which`, no runtime discovery). Instead:

- `exported_bins` contains explicit paths as policy.
- `capture` parses `distrobox.ini` into the manifest.
- `apply` generates `distrobox.ini` from the manifest and runs exports.

This keeps the workflow deterministic and reviewable, even when binaries live in `$HOME` (e.g., `~/.cargo/bin`).

### Environment Variables

The `env` field provides structured environment variable configuration.

**Schema:**

```json
{
  "env": {
    "EDITOR": "nvim",
    "RUST_BACKTRACE": "1"
  }
}
```

**Semantics:**

- Key-value pairs
- Cannot include `PATH` (use the `path` field instead)
- Generated as `--env=KEY=value` in `additional_flags`

### Additional Flags

The `additional_flags` field is a pass-through for podman/distrobox flags not covered by structured fields.

**Validation rules:**

- Cannot set the `PATH` environment variable in any form:
  - `--env=PATH=...`
  - `--env PATH=...`
  - `-e PATH=...`
  - `-e=PATH=...`
- For PATH configuration, use the `path` field instead

**Example:**

```json
{
  "path": ["~/.local/bin"],
  "env": { "EDITOR": "nvim" },
  "additional_flags": ["--userns=keep-id"]
}
```

**Generated `additional_flags` in distrobox.ini:**

```ini
additional_flags="--env=PATH=~/.local/bin:$PATH" "--env=EDITOR=nvim" "--userns=keep-id"
```

### Host Environment Configuration

For the **host** side (ensuring `~/.local/bin` is in PATH for VS Code and GNOME session), use systemd's `environment.d`:

```bash
# ~/.config/environment.d/10-distrobox-exports.conf
PATH="$HOME/.local/bin:$PATH"
```

This is read by `systemd --user` at login and applies to all GUI apps, terminals, and VS Code—no shell configuration needed.

Alternatively, bake into the OS image:

```dockerfile
COPY system/environment.d/10-distrobox-exports.conf /etc/environment.d/
```

### Apply Implementation

1. Load `manifests/distrobox.json`
2. Generate `distrobox.ini` (in repo root or configured location)
3. Run `distrobox assemble create --file distrobox.ini`
4. Optionally run export verification (ensure shim paths exist)

### Capture Implementation

1. Read `distrobox.ini`
2. Parse entries into `manifests/distrobox.json`
3. Normalize fields (packages list, exported bins paths)
4. Store back into manifest in a stable order

### Legacy Toolbox Compatibility

- Toolbox is supported but treated as legacy
- If `distrobox` is available, it is preferred for dev workflows
- `bkt dev` may be retained as a wrapper for `bkt distrobox` during transition

## Drawbacks

- Adds another manifest type to maintain
- Requires parsing and generating INI (new parser needed)
- Users must install Distrobox explicitly

## Rationale and Alternatives

### Alternative 1: Let Distrobox Own Exports

Use `distrobox.ini` directly without bkt manifest. Rejected because:

- No git-tracked source of truth
- Doesn’t align with bkt’s capture/apply model
- Difficult to reconcile with other manifests

### Alternative 2: Keep Toolbox Workflow

Rejected because it keeps the delegation complexity that motivated this RFC.

### Alternative 3: Use Containerfile-Only Approach

Generate a Containerfile and ignore `distrobox.ini`. Rejected because:

- Ignores Distrobox-native workflow
- Misses export integration

## Unresolved Questions

1. **Where should `distrobox.ini` live?**
   - Repo root vs `~/.config/distrobox/distrobox.ini`
   - Should bkt manage one file or multiple?

2. **Should bkt own Distrobox lifecycle?**
   - Always call `distrobox assemble create`
   - Or only generate the INI and let the user run assemble?

3. **How should exports be surfaced in bkt?**
   - Dedicated `bkt distrobox export add/remove` commands
   - Or just edit manifest directly and reapply?

4. **How do we handle multiple containers?**
   - Single `bootc-dev` container only
   - Or allow multiple entries in manifest?

5. **Should we generate `toolbox/Containerfile` still?**
   - Keep for image builds or drop in favor of Distrobox `additional_packages`?

6. **How should we migrate existing toolbox manifests?**
   - Auto-convert `toolbox-packages.json` → `distrobox.json`?
   - Keep both for a transition period?

## Future Possibilities

- `bkt distrobox status` to compare manifest vs actual containers
- Exported app management (`exported_apps`)
- Multiple dev containers with named profiles
- Integration with `bkt dev` toolchain tracking

## Implementation Checklist

- [ ] Define `distrobox.schema.json`
- [ ] Add `manifests/distrobox.json`
- [ ] Add `bkt distrobox` command group (capture/apply/status)
- [ ] INI parser/serializer for `distrobox.ini`
- [ ] Capture support from existing `distrobox.ini`
- [ ] Apply support via `distrobox assemble create`
- [ ] Migration helper from toolbox manifests
- [ ] Documentation updates (RFC-0003, README)
