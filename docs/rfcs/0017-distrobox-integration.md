# RFC 0017: Distrobox Integration and Exported Shims

- Feature Name: `distrobox_integration`
- Start Date: 2026-01-20
- RFC PR: (leave this empty until PR is opened)
- Tracking Issue: (leave this empty)

## Summary

Integrate Distrobox as the developer container workflow using `manifests/distrobox.json` as the git-tracked source of truth and `distrobox.ini` (repo root) as the native target. `bkt distrobox apply` renders `distrobox.ini`, runs `distrobox assemble create`, and exports binaries defined in the manifest. `bkt distrobox capture` parses `distrobox.ini` back into the manifest. Binary locations are declarative: manifests list explicit paths, not runtime discovery.

The goal is to shift the default workflow to **host-first** development (VS Code on host), with exported shims running inside the Distrobox container. This reduces the need for delegation logic and eliminates most "run inside the container" friction.

## Motivation

The current toolbox-based workflow assumes users operate **inside** the container, then delegate to the host for actions like `flatpak`, `gnome-extensions`, and `gsettings`. This has caused ongoing friction:

- Frequent context switching between host and container
- Heavy reliance on `flatpak-spawn --host`
- VS Code often needs to attach to the container
- Complex detection and delegation paths

Distrobox provides a better fit for the intended user experience by supporting **exported binaries**, allowing the user to stay on the host while seamlessly executing tools inside the container. Distrobox also provides a declarative manifest (`distrobox.ini`) that can be treated as a native system artifact similar to gsettings and flatpak overrides.

### Guiding Principles

1. **Host-first workflow**: Developers live on the host; tool execution is delegated into the container via exported shims.
2. **Native format as target**: `distrobox.ini` is the system state; bkt captures/applies it.
3. **GitOps source of truth**: A bkt manifest controls the desired state, generating `distrobox.ini` and applying it.
4. **Avoid toolchain lock-in**: Use Distrobox’s native features wherever possible (assemble, export).

## Goals

- Support Distrobox as the preferred dev-container backend
- Manage exported binaries (shims) declaratively
- Capture and apply `distrobox.ini` through bkt
- Preserve a git-tracked manifest as the source of truth
- Minimize need for container delegation logic

## Non-Goals

- Supporting multiple users or multi-machine orchestration
- Replacing Distrobox’s own configuration tools
- Rewriting Distrobox features inside bkt

## Guide-level Explanation

### New Workflow (Host-First)

```
Host (VS Code, shell)
  └── exported shim (cargo, rustc, npm, etc.)
        └── distrobox enter bootc-dev -- <command>
```

### Distrobox as Native Target

bkt treats `distrobox.ini` as the native state in the same way it treats gsettings and flatpak state:

```
┌─────────────────────┐
│  distrobox.ini      │  ← Native Distrobox config
└──────────┬──────────┘
           │ capture / apply
┌──────────▼──────────┐
│  manifests/         │  ← Git-tracked source of truth
│  distrobox.json     │
└─────────────────────┘
```

### Example bkt Manifest

```json
{
  "$schema": "../schemas/distrobox.schema.json",
  "containers": {
    "bootc-dev": {
      "image": "ghcr.io/wycats/bootc-toolbox:latest",
      "packages": ["gcc", "libatomic"],
      "bins": {
        "from": ["~/.cargo/bin", "~/.proto/shims"],
        "also": ["/usr/local/bin/nu", "~/.proto/bin/proto"],
        "to": "~/.local/bin/distrobox"
      },
      "init_hooks": ["rustup default stable", "rustup update stable"],
      "pull": true,
      "init": false,
      "root": false,
      "path": ["~/.local/bin", "~/.local/bin/distrobox", "$PATH"]
    }
  }
}
```

### Generated `distrobox.ini`

```ini
# Generated by bkt
# Source: manifests/distrobox.json

[bootc-dev]
image=ghcr.io/wycats/bootc-toolbox:latest
additional_packages="gcc libatomic"
exported_bins="/usr/local/bin/nu ~/.proto/bin/proto"
exported_bins_path="~/.local/bin/distrobox"
init_hooks="rustup default stable; rustup update stable"
pull=true
init=false
root=false
additional_flags="--env=PATH=~/.local/bin:~/.local/bin/distrobox:$PATH"
```

### Commands

```bash
# Capture current distrobox.ini into manifest
bkt distrobox capture

# Capture packages from a running container (optional)
bkt distrobox capture --packages bootc-dev

# Apply manifest to regenerate distrobox.ini, run assemble, and export bins
bkt distrobox apply
```

## Reference-level Explanation

### New Manifest Type

Add a new manifest file:

- `manifests/distrobox.json`
- Schema: `schemas/distrobox.schema.json`

### Distrobox INI Mapping

| Manifest Field     | Distrobox INI Key        | Notes                                     |
| ------------------ | ------------------------ | ----------------------------------------- |
| `image`            | `image`                  | Required                                  |
| `packages`         | `additional_packages`    | Joined as space-separated list            |
| `bins.also`        | `exported_bins`          | Space-separated explicit paths            |
| `bins.to`          | `exported_bins_path`     | Default `~/.local/bin` if set             |
| `bins.from`        | (not in INI)             | Used by `bkt` to export all bins in a dir |
| `exported_apps`    | `exported_apps`          | Optional                                  |
| `init_hooks`       | `init_hooks`             | One per line or compound list             |
| `pre_init_hooks`   | `pre_init_hooks`         | Optional                                  |
| `volume`           | `volume`                 | Optional                                  |
| `pull`             | `pull`                   | Boolean                                   |
| `init`             | `init`                   | Boolean                                   |
| `root`             | `root`                   | Boolean                                   |
| `path`             | (via `additional_flags`) | See PATH Configuration below              |
| `env`              | (via `additional_flags`) | See Environment Variables below           |
| `additional_flags` | `additional_flags`       | Pass-through; cannot set PATH             |

### PATH Configuration

The `path` field provides shell-agnostic PATH configuration for the container environment.

**Schema:**

```json
{
  "path": ["~/.local/bin", "~/.cargo/bin"]
}
```

**Semantics:**

- Array of directory paths
- Prepended to `$PATH` by default
- Include literal `"$PATH"` to control placement
- Empty array = no PATH modification

**Examples:**

```json
// Default: prepend to PATH
"path": ["~/.local/bin"]
// → --env=PATH=~/.local/bin:$PATH

// Explicit placement
"path": ["~/.local/bin", "$PATH", "/opt/fallback"]
// → --env=PATH=~/.local/bin:$PATH:/opt/fallback
```

**Why shell-agnostic?** Using `--env=PATH=...` via `additional_flags` is set by the container runtime before any shell starts. Works for bash, zsh, nushell, fish, or any process.

### Deterministic Binary Locations

`bkt` does **not** infer binary locations (no `which`, no runtime discovery). Instead:

- `bins.also` lists explicit paths to export.
- `bins.from` lists directories; `bkt distrobox apply` exports each file it finds there.
- `capture` parses `distrobox.ini` into the manifest (preserving `bins.from` from the existing manifest).

This keeps the workflow deterministic and reviewable, even when binaries live in `$HOME` (e.g., `~/.cargo/bin`).

### Environment Variables

The `env` field provides structured environment variable configuration.

**Schema:**

```json
{
  "env": {
    "EDITOR": "nvim",
    "RUST_BACKTRACE": "1"
  }
}
```

**Semantics:**

- Key-value pairs
- Cannot include `PATH` (use the `path` field instead)
- Generated as `--env=KEY=value` in `additional_flags`

### Additional Flags

The `additional_flags` field is a pass-through for podman/distrobox flags not covered by structured fields.

**Validation rules:**

- Cannot set the `PATH` environment variable in any form:
  - `--env=PATH=...`
  - `--env PATH=...`
  - `-e PATH=...`
  - `-e=PATH=...`
- For PATH configuration, use the `path` field instead

**Example:**

```json
{
  "path": ["~/.local/bin"],
  "env": { "EDITOR": "nvim" },
  "additional_flags": ["--userns=keep-id"]
}
```

**Generated `additional_flags` in distrobox.ini:**

```ini
additional_flags="--env=PATH=~/.local/bin:$PATH" "--env=EDITOR=nvim" "--userns=keep-id"
```

### Host Environment Configuration

For the **host** side (ensuring `~/.local/bin` is in PATH for VS Code and GNOME session), use systemd's `environment.d`:

```bash
# ~/.config/environment.d/10-distrobox-exports.conf
PATH="$HOME/.local/bin:$PATH"
```

This is read by `systemd --user` at login and applies to all GUI apps, terminals, and VS Code—no shell configuration needed.

Alternatively, bake into the OS image:

```dockerfile
COPY system/environment.d/10-distrobox-exports.conf /etc/environment.d/
```

### Apply Implementation

1. Load `manifests/distrobox.json`
2. Generate `distrobox.ini` in the repo root
3. Run `distrobox assemble create --replace --name <container> --file distrobox.ini`
4. Export binaries from `bins.from` directories and `bins.also` entries via `distrobox-export`

### Capture Implementation

1. Read `distrobox.ini` from the repo root
2. Parse entries into `manifests/distrobox.json`
3. Preserve `bins.from` and `bins.to` from the existing manifest (INI does not encode them)
4. Optionally capture packages from a running container with `bkt distrobox capture --packages <name>`

### Legacy Toolbox Compatibility

- Toolbox is supported but treated as legacy
- If `distrobox` is available, it is preferred for dev workflows
- `bkt dev` may be retained as a wrapper for `bkt distrobox` during transition

## Drawbacks

- Adds another manifest type to maintain
- Requires parsing and generating INI (new parser needed)
- Users must install Distrobox explicitly

## Rationale and Alternatives

### Alternative 1: Let Distrobox Own Exports

Use `distrobox.ini` directly without bkt manifest. Rejected because:

- No git-tracked source of truth
- Doesn’t align with bkt’s capture/apply model
- Difficult to reconcile with other manifests

### Alternative 2: Keep Toolbox Workflow

Rejected because it keeps the delegation complexity that motivated this RFC.

### Alternative 3: Use Containerfile-Only Approach

Generate a Containerfile and ignore `distrobox.ini`. Rejected because:

- Ignores Distrobox-native workflow
- Misses export integration

## Gaps

- No helper subcommands like `bkt distrobox export add/remove` or `bkt distrobox package add/remove`.
- No `bkt distrobox status` comparison command.
- `bkt dev` is still a separate workflow; it does not wrap `bkt distrobox`.
