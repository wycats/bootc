name: build-and-push

on:
  push:
    branches: [main]
  pull_request_target:
    # Runs main's workflow with PR's code - requires environment approval
    # This allows cache sharing between PRs and main while maintaining security
    branches: [main]
  schedule:
    # Hourly cheap poll of upstream digest
    - cron: "0 * * * *"
    # Nightly forced rebuild to pick up RPM repo updates even if upstream digest doesn't change
    - cron: "0 3 * * *"
  workflow_dispatch:

# Workflow-level permissions - jobs override these as needed
permissions:
  contents: read
  packages: read
  pull-requests: read

concurrency:
  # Ensure we don't pile up scheduled builds (they can take a while).
  # For PRs, use PR number so different PRs don't cancel each other.
  # For other events, use ref_name so pushes to main cancel previous main runs.
  group: build-and-push-${{ github.event.pull_request.number || github.ref_name }}-${{ github.event_name }}
  cancel-in-progress: true

env:
  # Must match the FROM line in Containerfile
  BASE_IMAGE: ghcr.io/ublue-os/bazzite-gnome:stable

jobs:
  # Run the same Rust checks as CI to ensure build doesn't fail on compilation
  rust-checks:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    defaults:
      run:
        working-directory: bkt
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # For PRs, checkout the PR branch, not main
          ref: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.sha || github.sha }}

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache Cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: bkt -> target
          shared-key: rust-ci
          # Only save cache on main to prevent PR cache pollution
          save-if: ${{ github.ref == 'refs/heads/main' }}

      - name: Check formatting
        run: cargo fmt --check

      - name: Run Clippy
        run: cargo clippy -- -D warnings

      - name: Run tests
        run: cargo test

      - name: Check Containerfile is in sync with manifests
        working-directory: ${{ github.workspace }}
        run: cargo run -p bkt --quiet -- containerfile check

  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.sha || github.sha }}

      - name: Check ostree filesystem patterns
        run: ./scripts/check-ostree-paths Containerfile

  check-upstream:
    runs-on: ubuntu-latest
    outputs:
      upstream_changed: ${{ steps.check.outputs.upstream_changed }}
      upstream_digest: ${{ steps.check.outputs.upstream_digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0

      - name: Install skopeo
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo jq

      - name: Check upstream digest
        id: check
        shell: bash
        run: |
          set -euo pipefail

          upstream_digest="$(skopeo inspect --format '{{.Digest}}' "docker://${BASE_IMAGE}")"
          echo "upstream_digest=${upstream_digest}" >> "$GITHUB_OUTPUT"

          # Compare against the last published image (if available). We embed
          # the last seen upstream digest as an image label.
          last_seen=""
          if skopeo inspect "docker://ghcr.io/${GITHUB_REPOSITORY}:latest" >/tmp/current.json 2>/dev/null; then
            last_seen="$(jq -r '.Labels["org.wycats.bootc.base.digest"] // empty' </tmp/current.json)"
          fi

          if [[ -z "${last_seen}" || "${upstream_digest}" != "${last_seen}" ]]; then
            echo "upstream_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "upstream_changed=false" >> "$GITHUB_OUTPUT"
          fi

  check-rpm-freshness:
    name: Check RPM freshness
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      rpms_changed: ${{ steps.check.outputs.rpms_changed }}
      cache_epoch: ${{ steps.check.outputs.cache_epoch }}
    steps:
      - name: Install skopeo
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo jq

      - name: Check RPM repo revisions against last image
        id: check
        shell: bash
        run: |
          set -euo pipefail

          # Each RPM repo publishes a repomd.xml with a <revision> timestamp
          # that changes whenever the repo contents change. We hash these
          # revisions — no need for dnf or rpm tooling on the Ubuntu runner.
          REPOS=(
            "vscode=https://packages.microsoft.com/yumrepos/vscode/repodata/repomd.xml"
            "edge=https://packages.microsoft.com/yumrepos/edge/repodata/repomd.xml"
            "1password=https://downloads.1password.com/linux/rpm/stable/x86_64/repodata/repomd.xml"
          )

          REVISIONS=""
          for entry in "${REPOS[@]}"; do
            name="${entry%%=*}"
            url="${entry#*=}"
            # Extract <revision> from repomd.xml (a Unix timestamp that changes on repo update)
            rev=$(curl -sf "$url" | grep -oP '(?<=<revision>)\d+' || echo "unknown")
            REVISIONS="${REVISIONS}${name}=${rev}\n"
            echo "  ${name}: revision ${rev}"
          done

          REPO_HASH=$(printf '%b' "$REVISIONS" | sha256sum | cut -d' ' -f1)
          echo "Combined repo hash: ${REPO_HASH}"

          # Compare against the hash embedded in the last published image
          LAST_HASH=""
          if skopeo inspect "docker://ghcr.io/${GITHUB_REPOSITORY}:latest" >/tmp/current.json 2>/dev/null; then
            LAST_HASH=$(jq -r '.Labels["org.wycats.bootc.rpm.hash"] // empty' </tmp/current.json)
          fi
          echo "Last image RPM hash: ${LAST_HASH:-none}"

          if [[ -z "${LAST_HASH}" || "${REPO_HASH}" != "${LAST_HASH}" ]]; then
            echo "rpms_changed=true" >> "$GITHUB_OUTPUT"
            echo "cache_epoch=${REPO_HASH}" >> "$GITHUB_OUTPUT"
            echo "::notice::RPM repo revision changed — will bust dnf cache layer"
          else
            echo "rpms_changed=false" >> "$GITHUB_OUTPUT"
            echo "cache_epoch=0" >> "$GITHUB_OUTPUT"
            echo "::notice::RPM repo revisions unchanged"
          fi

  validate-manifests:
    name: Validate manifests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.sha || github.sha }}

      - name: Validate JSON syntax
        run: |
          echo "Checking JSON syntax..."
          for manifest in manifests/*.json; do
            echo "  → $manifest"
            jq empty "$manifest" || exit 1
          done
          echo "✓ All manifests have valid JSON syntax"

      - name: Validate against schemas
        run: |
          npm install -g ajv-cli ajv-formats

          echo "Validating manifests against schemas..."

          # Map manifests to their schemas
          declare -A SCHEMA_MAP=(
            ["manifests/flatpak-apps.json"]="schemas/flatpak-apps.schema.json"
            ["manifests/flatpak-remotes.json"]="schemas/flatpak-remotes.schema.json"
            ["manifests/external-repos.json"]="schemas/external-repos.schema.json"
            ["manifests/gnome-extensions.json"]="schemas/gnome-extensions.schema.json"
            ["manifests/gsettings.json"]="schemas/gsettings.schema.json"
            ["manifests/host-shims.json"]="schemas/host-shims.schema.json"
          )

          for manifest in "${!SCHEMA_MAP[@]}"; do
            schema="${SCHEMA_MAP[$manifest]}"
            echo "  → $manifest against $schema"
            ajv validate -s "$schema" -d "$manifest" --spec=draft2020 -c ajv-formats || exit 1
          done

          echo "✓ All manifests are valid"

  check-schemas-current:
    name: Check schemas are current
    runs-on: ubuntu-latest
    timeout-minutes: 15
    defaults:
      run:
        working-directory: bkt
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.sha || github.sha }}

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: bkt -> target
          shared-key: rust-ci
          save-if: ${{ github.ref == 'refs/heads/main' }}

      - name: Build bkt
        run: cargo build --release

      - name: Generate schemas
        working-directory: .
        run: |
          mkdir -p /tmp/schemas-generated
          ./bkt/target/release/bkt schema generate -o /tmp/schemas-generated

      - name: Compare with committed schemas
        working-directory: .
        run: |
          echo "Checking if committed schemas match generated schemas..."
          if ! diff -r schemas /tmp/schemas-generated; then
            echo ""
            echo "::error::Committed schemas are out of sync with Rust types!"
            echo "Run: cd bkt && cargo run -- schema generate -o ../schemas"
            exit 1
          fi
          echo "✓ Schemas are up to date"

  nightly:
    runs-on: ubuntu-latest
    outputs:
      force_rebuild: ${{ steps.flag.outputs.force_rebuild }}
    steps:
      - name: Determine nightly schedule
        id: flag
        shell: bash
        run: |
          set -euo pipefail
          # GitHub provides the triggering cron string in github.event.schedule for scheduled runs.
          # For non-scheduled events (push/workflow_dispatch), we never force a rebuild here.
          utc_hour="$(date -u +%H)"
          # At 03:00 UTC we want to force a rebuild, even if the run was
          # triggered by the hourly cron.
          if [[ "${{ github.event_name }}" == "schedule" && ( "${{ github.event.schedule }}" == "0 3 * * *" || ( "${{ github.event.schedule }}" == "0 * * * *" && "${utc_hour}" == "03" ) ) ]]; then
            echo "force_rebuild=true" >> "$GITHUB_OUTPUT"
          else
            echo "force_rebuild=false" >> "$GITHUB_OUTPUT"
          fi

  build:
    needs:
      [
        rust-checks,
        lint,
        validate-manifests,
        check-schemas-current,
        check-upstream,
        check-rpm-freshness,
        nightly,
      ]
    runs-on: ubuntu-latest
    # PRs require approval via 'pr-build' environment before running
    # This ensures maintainer review before granting cache/registry access
    environment: ${{ github.event_name == 'pull_request_target' && 'pr-build' || 'build' }}
    # Permissions: packages:write for GHCR cache, contents:write only needed for releases (gated by step condition)
    permissions:
      contents: write
      packages: write
    if: |
      github.event_name == 'push' ||
      github.event_name == 'pull_request_target' ||
      github.event_name == 'workflow_dispatch' ||
      needs.check-upstream.outputs.upstream_changed == 'true' ||
      needs.check-rpm-freshness.outputs.rpms_changed == 'true' ||
      needs.nightly.outputs.force_rebuild == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # For PRs from forks, we need both the repository and ref to checkout correctly
          repository: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.repo.full_name || github.repository }}
          ref: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-unknown-linux-gnu,x86_64-unknown-linux-musl

      - name: Install musl tools
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools

      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            bkt -> target
            bkt-build -> target
          # Different key for cross-compiled release builds
          shared-key: rust-release-x86_64
          save-if: ${{ github.ref == 'refs/heads/main' }}

      - name: Build bkt (release)
        run: |
          cd bkt
          cargo build --release --target x86_64-unknown-linux-gnu
          chmod +x target/x86_64-unknown-linux-gnu/release/bkt
          cp target/x86_64-unknown-linux-gnu/release/bkt ../scripts/bkt

      - name: Build bkt-build (musl static)
        run: |
          cd bkt-build
          cargo build --release --target x86_64-unknown-linux-musl
          chmod +x target/x86_64-unknown-linux-musl/release/bkt-build
          cp target/x86_64-unknown-linux-musl/release/bkt-build ../scripts/bkt-build

      - name: Generate build info
        id: build-info
        run: |
          set -euo pipefail

          # Get the previous commit (from last successful build)
          PREV_COMMIT="${{ github.event.before }}"
          CURR_COMMIT="${{ github.sha }}"

          # For scheduled runs, we need to find the previous build commit
          if [[ "${{ github.event_name }}" == "schedule" || -z "$PREV_COMMIT" || "$PREV_COMMIT" == "0000000000000000000000000000000000000000" ]]; then
            # Get commit from HEAD~1
            PREV_COMMIT=$(git rev-list --max-count=1 HEAD~1 2>/dev/null || echo "$CURR_COMMIT")
          fi

          # Generate build info JSON
          ./scripts/bkt build-info generate \
            --from "$PREV_COMMIT" \
            --to "$CURR_COMMIT" \
            --output build-info.json || {
            echo "Build info generation failed, creating empty placeholder"
            echo '{"schema_version":"1.0.0","build":{"commit":"'"$CURR_COMMIT"'","timestamp":"'"$(date -Iseconds)"'"},"manifests":{}}' > build-info.json
          }

          # Render to markdown
          ./scripts/bkt build-info render build-info.json --output build-info.md || {
            echo "Markdown rendering failed, creating placeholder"
            echo "# Build Info" > build-info.md
            echo "" >> build-info.md
            echo "Commit: $CURR_COMMIT" >> build-info.md
          }

          # Generate 512-char summary for OCI annotation
          RELEASE_TAG="sha-${CURR_COMMIT:0:7}"
          SUMMARY=$(./scripts/bkt build-info summary build-info.json --max-length 400 2>/dev/null || echo "Build update")
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/${RELEASE_TAG}"
          SUMMARY="${SUMMARY} ⮕ ${RELEASE_URL}"

          echo "summary<<EOF" >> "$GITHUB_OUTPUT"
          echo "$SUMMARY" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "release_tag=${RELEASE_TAG}" >> "$GITHUB_OUTPUT"

      - name: Create release with build info
        # Skip release creation on PRs (just validating the build)
        # This also ensures contents:write permission is only used for non-PR events
        if: github.event_name != 'pull_request' && github.event_name != 'pull_request_target'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.build-info.outputs.release_tag }}
          name: "Build ${{ steps.build-info.outputs.release_tag }}"
          body_path: build-info.md
          files: |
            build-info.json
            build-info.md
          make_latest: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Free disk space
        shell: bash
        run: |
          set -euxo pipefail
          df -h
          sudo rm -rf /usr/share/dotnet /opt/ghc /usr/local/lib/android /usr/local/share/boost || true
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*
          sudo docker system prune -af || true
          df -h

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        # Always login - PRs are gated by environment approval
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN || github.token }}

      - name: Pin Containerfile to detected digest
        run: |
          # Replace floating :stable tag with the exact digest we detected
          # This eliminates the race condition where the tag could move between detection and build
          UPSTREAM_DIGEST="${{ needs.check-upstream.outputs.upstream_digest }}"
          echo "Pinning Containerfile to digest: ${UPSTREAM_DIGEST}"
          sed -i "s|FROM ${BASE_IMAGE} AS base|FROM ${BASE_IMAGE}@${UPSTREAM_DIGEST} AS base|" Containerfile
          echo "Updated FROM line:"
          grep "AS base" Containerfile | head -1

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=latest
            type=sha

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Containerfile
          # Push on any non-PR event; PRs just validate the build and warm the cache
          push: ${{ github.event_name != 'pull_request_target' }}
          tags: ${{ steps.meta.outputs.tags }}
          # When RPM versions change, DNF_CACHE_EPOCH changes, busting the dnf install layer.
          # When unchanged, the value is '0' and the cached layer is reused.
          build-args: |
            DNF_CACHE_EPOCH=${{ needs.check-rpm-freshness.outputs.cache_epoch }}
          labels: |
            ${{ steps.meta.outputs.labels }}
            org.wycats.bootc.base.image=${{ env.BASE_IMAGE }}
            org.wycats.bootc.base.digest=${{ needs.check-upstream.outputs.upstream_digest }}
            org.wycats.bootc.rpm.hash=${{ needs.check-rpm-freshness.outputs.cache_epoch }}
            org.opencontainers.image.description=${{ steps.build-info.outputs.summary }}
          # Registry cache - shared across all branches (unlike GHA cache)
          cache-from: type=registry,ref=ghcr.io/${{ github.repository }}:buildcache
          cache-to: type=registry,ref=ghcr.io/${{ github.repository }}:buildcache,mode=max

  build-toolbox:
    runs-on: ubuntu-latest
    # PRs require approval via 'pr-build' environment
    environment: ${{ github.event_name == 'pull_request_target' && 'pr-build' || '' }}
    # Elevated permissions for registry push
    permissions:
      packages: write
    # Build toolbox on push, PR, or workflow_dispatch (not on schedule)
    if: github.event_name == 'push' || github.event_name == 'pull_request_target' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.sha || github.sha }}

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        # Always login - PRs are gated by environment approval
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN || github.token }}

      - name: Docker metadata (toolbox)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}-toolbox
          tags: |
            type=raw,value=latest
            type=sha

      - name: Build and push toolbox
        uses: docker/build-push-action@v6
        with:
          context: ./toolbox
          file: ./toolbox/Containerfile
          # Push on any non-PR event; PRs just validate the build and warm the cache
          push: ${{ github.event_name != 'pull_request_target' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # Registry cache - shared across all branches
          cache-from: type=registry,ref=ghcr.io/${{ github.repository }}-toolbox:buildcache
          cache-to: type=registry,ref=ghcr.io/${{ github.repository }}-toolbox:buildcache,mode=max
