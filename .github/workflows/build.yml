name: build-and-push

on:
  push:
    branches: [main]
    paths-ignore:
      - upstream/bazzite-stable.digest
      - upstream/getnf.ref
      - upstream/getnf.version
      - upstream/getnf.sha256
  schedule:
    # Hourly cheap poll of upstream digest
    - cron: "0 * * * *"
    # Nightly forced rebuild to pick up RPM repo updates even if upstream digest doesn't change
    - cron: "0 3 * * *"
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  pull-requests: write

concurrency:
  group: build-and-push-${{ github.ref }}
  # Let manual/push runs cancel anything in-flight, but don't let the hourly
  # scheduled runs cancel a manual build-and-push.
  cancel-in-progress: ${{ github.event_name != 'schedule' }}

env:
  BASE_IMAGE: ghcr.io/ublue-os/bazzite:stable
  DIGEST_FILE: upstream/bazzite-stable.digest
  GETNF_REF_FILE: upstream/getnf.ref
  GETNF_VERSION_FILE: upstream/getnf.version
  GETNF_SHA256_FILE: upstream/getnf.sha256

jobs:
  # Run the same Rust checks as CI to ensure build doesn't fail on compilation
  rust-checks:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    defaults:
      run:
        working-directory: bkt
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache Cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: bkt -> target

      - name: Check formatting
        run: cargo fmt --check

      - name: Run Clippy
        run: cargo clippy -- -D warnings

      - name: Run tests
        run: cargo test

  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check ostree filesystem patterns
        run: ./scripts/check-ostree-paths Containerfile

  check-upstream:
    runs-on: ubuntu-latest
    outputs:
      upstream_changed: ${{ steps.check.outputs.upstream_changed }}
      force_rebuild: ${{ steps.check.outputs.force_rebuild }}
      upstream_digest: ${{ steps.check.outputs.upstream_digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Install skopeo
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo

      - name: Check upstream digest
        id: check
        shell: bash
        run: |
          set -euo pipefail

          # Nightly forced rebuild is determined by a separate job (see below).
          force_rebuild=false

          upstream_digest="$(skopeo inspect --format '{{.Digest}}' "docker://${BASE_IMAGE}")"
          echo "upstream_digest=${upstream_digest}" >> "$GITHUB_OUTPUT"
          echo "force_rebuild=${force_rebuild}" >> "$GITHUB_OUTPUT"

          current_digest=""
          if [[ -f "${DIGEST_FILE}" ]]; then
            current_digest="$(grep -Eo '^sha256:[0-9a-f]{64}$' "${DIGEST_FILE}" | tail -n 1 || true)"
          fi

          if [[ "${upstream_digest}" != "${current_digest}" ]]; then
            echo "upstream_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "upstream_changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Update digest file
        if: steps.check.outputs.upstream_changed == 'true' && (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch')
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${DIGEST_FILE}")"
          {
            echo "# Updated automatically by GitHub Actions."
            echo "# This is the last-seen digest for ${BASE_IMAGE}"
            echo "# Format: sha256:..."
            echo "${{ steps.check.outputs.upstream_digest }}"
          } > "${DIGEST_FILE}"

      - name: Create PR for digest update
        id: create-digest-pr
        if: steps.check.outputs.upstream_changed == 'true' && (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch')
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ github.token }}
          commit-message: "chore(upstream): bump bazzite stable digest"
          title: "chore(upstream): bump bazzite stable digest"
          body: |
            Automated PR to update upstream bazzite digest.

            This PR was created automatically by the build workflow when a new upstream image was detected.

            **Upstream digest:** `${{ steps.check.outputs.upstream_digest }}`
          branch: chore/bump-bazzite-digest
          delete-branch: true

      - name: Enable auto-merge for digest PR
        if: steps.create-digest-pr.outputs.pull-request-number
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh pr merge ${{ steps.create-digest-pr.outputs.pull-request-number }} --auto --squash || \
            echo "::warning::Auto-merge not available - PR requires manual merge"

  check-getnf:
    runs-on: ubuntu-latest
    outputs:
      getnf_changed: ${{ steps.check.outputs.getnf_changed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Check getnf upstream script
        id: check
        shell: bash
        env:
          RAW_URL: https://raw.githubusercontent.com/getnf/getnf
        run: |
          set -euo pipefail

          curl_common=(
            --fail
            --silent
            --show-error
            --location
            --retry 5
            --retry-all-errors
            --retry-delay 2
          )

          # Resolve the moving branch to an immutable commit SHA so the build stays reproducible.
          # Pin to an immutable commit SHA so builds don't break when upstream moves.
          ref="$(curl "${curl_common[@]}" -H 'Accept: application/vnd.github+json' https://api.github.com/repos/getnf/getnf/commits/main | jq -r .sha)"
          url="${RAW_URL}/${ref}/getnf"

          # Download to a temp file instead of a variable to preserve the trailing
          # newline. Command substitution strips trailing newlines, which would
          # produce a different sha256 than what the Containerfile downloads.
          tmpfile="$(mktemp)"
          trap 'rm -f "$tmpfile"' EXIT
          curl "${curl_common[@]}" "$url" -o "$tmpfile"
          sha="$(sha256sum "$tmpfile" | cut -d" " -f1)"
          ver="$(grep -E "^readonly VERSION=\"" "$tmpfile" | head -n1 | sed -E "s/^readonly VERSION=\"([^\"]+)\"/\1/" || true)"
          ver="${ver:-unknown}"

          current_sha=""
          if [[ -f "${GETNF_SHA256_FILE}" ]]; then
            current_sha="$(tr -d "\n" < "${GETNF_SHA256_FILE}" || true)"
          fi

          if [[ "${sha}" != "${current_sha}" ]]; then
            echo "getnf_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "getnf_changed=false" >> "$GITHUB_OUTPUT"
          fi

          if [[ "${{ github.event_name }}" != "schedule" && "${{ github.event_name }}" != "workflow_dispatch" ]]; then
            exit 0
          fi

          if [[ "${sha}" == "${current_sha}" ]]; then
            exit 0
          fi

          # Store version info for PR creation step (files written after branch checkout to avoid race condition)
          echo "getnf_version=${ver}" >> "$GITHUB_OUTPUT"
          echo "getnf_ref=${ref}" >> "$GITHUB_OUTPUT"
          echo "getnf_sha=${sha}" >> "$GITHUB_OUTPUT"

      - name: Update getnf files
        if: steps.check.outputs.getnf_changed == 'true' && (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch')
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${GETNF_REF_FILE}")"
          echo "${{ steps.check.outputs.getnf_ref }}" > "${GETNF_REF_FILE}"
          echo "${{ steps.check.outputs.getnf_version }}" > "${GETNF_VERSION_FILE}"
          echo "${{ steps.check.outputs.getnf_sha }}" > "${GETNF_SHA256_FILE}"

      - name: Create PR for getnf update
        id: create-getnf-pr
        if: steps.check.outputs.getnf_changed == 'true' && (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch')
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ github.token }}
          commit-message: "chore(upstream): bump getnf (${{ steps.check.outputs.getnf_version }})"
          title: "chore(upstream): bump getnf (${{ steps.check.outputs.getnf_version }})"
          body: |
            Automated PR to update getnf upstream script.

            This PR was created automatically by the build workflow when a new getnf version was detected.

            **Version:** `${{ steps.check.outputs.getnf_version }}`
            **Ref:** `${{ steps.check.outputs.getnf_ref }}`
            **SHA256:** `${{ steps.check.outputs.getnf_sha }}`
          branch: chore/bump-getnf
          delete-branch: true

      - name: Enable auto-merge for getnf PR
        if: steps.create-getnf-pr.outputs.pull-request-number
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh pr merge ${{ steps.create-getnf-pr.outputs.pull-request-number }} --auto --squash || \
            echo "::warning::Auto-merge not available - PR requires manual merge"

  nightly:
    runs-on: ubuntu-latest
    outputs:
      force_rebuild: ${{ steps.flag.outputs.force_rebuild }}
    steps:
      - name: Determine nightly schedule
        id: flag
        shell: bash
        run: |
          set -euo pipefail
          # GitHub provides the triggering cron string in github.event.schedule for scheduled runs.
          # For non-scheduled events (push/workflow_dispatch), we never force a rebuild here.
          utc_hour="$(date -u +%H)"
          # At 03:00 UTC we want to force a rebuild, even if the run was
          # triggered by the hourly cron.
          if [[ "${{ github.event_name }}" == "schedule" && ( "${{ github.event.schedule }}" == "0 3 * * *" || ( "${{ github.event.schedule }}" == "0 * * * *" && "${utc_hour}" == "03" ) ) ]]; then
            echo "force_rebuild=true" >> "$GITHUB_OUTPUT"
          else
            echo "force_rebuild=false" >> "$GITHUB_OUTPUT"
          fi

  build:
    needs: [rust-checks, lint, check-upstream, check-getnf, nightly]
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch' ||
      needs.check-upstream.outputs.upstream_changed == 'true' ||
      needs.check-getnf.outputs.getnf_changed == 'true' ||
      needs.nightly.outputs.force_rebuild == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-unknown-linux-gnu

      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: bkt

      - name: Build bkt (release)
        run: |
          cd bkt
          cargo build --release --target x86_64-unknown-linux-gnu
          chmod +x target/x86_64-unknown-linux-gnu/release/bkt
          cp target/x86_64-unknown-linux-gnu/release/bkt ../scripts/bkt

      - name: Free disk space
        shell: bash
        run: |
          set -euxo pipefail
          df -h
          sudo rm -rf /usr/share/dotnet /opt/ghc /usr/local/lib/android /usr/local/share/boost || true
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*
          sudo docker system prune -af || true
          df -h

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN || github.token }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=latest
            type=sha

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Containerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-toolbox:
    runs-on: ubuntu-latest
    # Build toolbox on push or workflow_dispatch, not on schedule
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN || github.token }}

      - name: Docker metadata (toolbox)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}-toolbox
          tags: |
            type=raw,value=latest
            type=sha

      - name: Build and push toolbox
        uses: docker/build-push-action@v6
        with:
          context: ./toolbox
          file: ./toolbox/Containerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
